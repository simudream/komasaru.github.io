<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pc_tips | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/pc-tips/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-11-26T00:06:16+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux - MTU 最適値の導出！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/26/linux-mtu-best-effort/"/>
    <updated>2015-11-26T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/26/linux-mtu-best-effort</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux で最適な MTU 値を導出する方法についての備忘録です。</p>

<!--more-->


<h3>1. MTU について</h3>

<p>MTU とは Maximum Transmission Unit の略で、ネットワーク上において１フレーム（１回の転送）で送信可能な IP パケットの最大サイズのこと。<br/>
（このサイズは IP ヘッダ ＋ ICMP ヘッダ ＋ データのサイズ）</p>

<h3>2. MTU 現在値の確認</h3>

<pre><code class="text">$ ifconfig
ifconfig
eth0      Link encap:イーサネット  ハードウェアアドレス XX:XX:XX:XX:XX:XX
          inetアドレス:192.168.XXX.XXX  ブロードキャスト:192.168.XXX.255  マスク:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  メトリック:1
          RXパケット:49793411 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:30012458 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:1000
          RXバイト:23207684202 (23.2 GB)  TXバイト:21221894153 (21.2 GB)
          割り込み:17

lo        Link encap:ローカルループバック
          inetアドレス:127.0.0.1  マスク:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  メトリック:1
          RXパケット:27117491 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:27117491 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:0
          RXバイト:32672340989 (32.6 GB)  TXバイト:32672340989 (32.6 GB)
</code></pre>

<p>eth0 の MTU 値が <code>1500</code> となっている。</p>

<h3>3. MTU 最適値の導出</h3>

<p>要は、様々なサイズのパケット（データ）を断片化せずに送信してみてロスしない最大値を求めればよい。<br/>
但し、「IP ヘッダ ＋ ICMP ヘッダ」が「28 バイト」あるので、 MTU に設定する値は +28 したものになる。
（送信先は存在する URL ならどこでもよい）</p>

<p>では、実際に導出作業を行なってみる。（大体の目星をつけて作業を行うとよいだろう）</p>

<p>以下では <code>ping</code> コマンドを使用するがオプションは次のとおり。</p>

<ul>
<li><code>-c 1</code> は、リクエスト回数を１回に設定するオプション</li>
<li><code>-s 9999</code> は、送信パケットサイズを 9999 に設定するオプション</li>
<li><code>-M do</code> は、パケットの断片化を行わないオプション</li>
</ul>


<p>まず、パケットサイズ 1400 バイトで送信してみる。</p>

<pre><code class="text"># ping -c 1 -s 1400 -M do www.linuxmint.com
PING www.linuxmint.com (213.175.215.218) 1400(1428) bytes of data.
1408 bytes from forums.linuxmint.com (213.175.215.218): icmp_seq=1 ttl=49 time=308 ms

--- www.linuxmint.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 308.674/308.674/308.674/0.000 ms
</code></pre>

<p><code>1 received, 0% packet loss</code> なので、正常に送信できているということ。</p>

<p>次に、パケットサイズ 1500 バイトで送信してみる。</p>

<pre><code class="text">$ ping -c 1 -s 1500 -M do www.linuxmint.com
PING www.linuxmint.com (213.175.215.218) 1500(1528) bytes of data.
ping: local error: Message too long, mtu=1454

--- www.linuxmint.com ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
</code></pre>

<p><code>0 received, +1 errors, 100% packet loss</code> なので、送信に失敗しているということ。</p>

<p>このように、パケットサイズを変更しながら絞り込んでいく。</p>

<p>今回の当方の環境の場合、パケットサイズ「1426 バイト」が正常に送信できる最大値であった。</p>

<p>よって、 MTU 値は IP ヘッダ ＋ ICMP ヘッダの 28 バイトをプラスした「1454 バイト」となる。<br/>
（ちなみに、この値は今回の当方の環境ではよく知られている最適な MTU 値）</p>

<h3>4. MTU 値の変更</h3>

<p>後は、MTU 値を前項で導出した値に変更すればよい。</p>

<pre><code class="text">$ ifconfig eth0 mtu 1454
</code></pre>

<p>但し、この設定は一時的なものなのでマシンを再起動すると元に戻ってしまう。</p>

<p>恒久的に変更するには、ネットワーク接続の編集の画面で MTU 値を「自動（もしくは、何らかの数値）」から変更、もしくは設定ファイル &ldquo;/etc/NetworkManager/system-connections/Wired\ connection\ 1&rdquo; 等を編集し、再起動（ネットワーク再接続）する。（Linux Mint 等の場合）</p>

<p>ちなみに、 CentOS の CUI ベースなら &ldquo;/etc/sysconfig/network-scripts/ifcfg-eth0&rdquo; 等を編集して再起動する。</p>

<hr />

<p>それほどネットワーク周りが改善されたと体感できないかもしれませんが、最適化しないよりはした方がよいでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - Apt パッケージリストアップデートで GPG 公開鍵の期限切れエラー！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/21/linux-mint-apt-gpg-pubkey-expired-error/"/>
    <updated>2015-11-21T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/21/linux-mint-apt-gpg-pubkey-expired-error</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux Mint で <code>apt-get update</code> すると公開鍵期限切れのエラーが発生するようになりました。</p>

<p>（以前「<a href="/2015/10/14/linux-mint-apt-gpg-pubkey-error/" title="Linux Mint - apt-get update で GPG 公開鍵エラー！">Linux Mint - apt-get update で GPG 公開鍵エラー！</a>」という記事も公開しています。参考までに）</p>

<p>以下、現象・原因・対策についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
</ul>


<h3>1. 現象</h3>

<p><code>sudo apt-get update</code> を実行すると以下のようなエラーが発生する。（アップデートマネージャでも同様）</p>

<pre><code class="text">W: GPG エラー: http://cran.ism.ac.jp trusty/ Release: 以下の署名が無効です: KEYEXPIRED 1445181253 KEYEXPIRED 1445181253 KEYEXPIRED 1445181253,
</code></pre>

<p>（ちなみに、今回の現象は統計解析用プログラミング言語 R のパッケージにに関するもの）</p>

<h3>2. 原因</h3>

<p>エラーメッセージに記載されているとおり、 <code>1445181253</code> というキーが <code>KEYEXPIRED</code>（期限切れ）になっているため。</p>

<h3>3. 対策</h3>

<p>まず、キーの状態を確認してみる。</p>

<pre><code class="text">$ apt-key list

pub   2048R/E084DAB9 2010-10-19 [満了: 2015-10-18]
uid                  Michael Rutter &lt;marutter@gmail.com&gt;
</code></pre>

<p>確かに期限が切れている。</p>

<p>従って、キーサーバに問い合わせて、公開鍵を再取得すればよい。</p>

<pre><code class="text">$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9
Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.UCCHrlWZQw --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys E084DAB9
gpg: 鍵E084DAB9をhkpからサーバーkeyserver.ubuntu.comに要求
gpg: 鍵E084DAB9:“Michael Rutter &lt;marutter@gmail.com&gt;”新しい署名を2個
gpg: 処理数の合計: 1
gpg:         新しい署名: 2
</code></pre>

<p>再度、キーの状態を確認してみる。</p>

<pre><code class="text">$ apt-key list

pub   2048R/E084DAB9 2010-10-19 [満了: 2020-10-16]
uid                  Michael Rutter &lt;marutter@gmail.com&gt;
sub   2048R/1CFF3E8F 2010-10-19 [満了: 2020-10-16]
</code></pre>

<p>満了日が延長された。</p>

<p>これで、正常に <code>sudo apt-get update</code> が実行できるはず。</p>

<hr />

<p>めったに遭遇しない事象なので、後学のために記録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - apt-get update で GPG 公開鍵エラー！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/14/linux-mint-apt-gpg-pubkey-error/"/>
    <updated>2015-10-14T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/14/linux-mint-apt-gpg-pubkey-error</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux Mint で、いつしか Apt パッケージの一覧を更新しようとすると GPG 公開鍵エラーが発生するようになりました。</p>

<p>以下、現象・原因・対策についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) を想定。</li>
</ul>


<h3>1. 現象</h3>

<p>Apt パッケージ一覧をアップデートした際に以下のようなエラーが発生する。（<code>W</code> なので分類としては「警告」でしょうが）<br/>
（以下は QGIS というパッケージの部分で発生した例で、実際のメッセージは１行）</p>

<pre><code class="text">$ sudo apt-get update

====&lt; 途中省略 &gt;====

W: GPG エラー: http://qgis.org trusty InRelease: 
公開鍵を利用できないため、以下の署名は検証できませんでした: NO_PUBKEY 3FF5FFCAD71472C4

====&lt; 以下省略 &gt;====
</code></pre>

<p>当然ながら、アップデートマネージャでも同じエラーが発生する。</p>

<h3>2. 原因</h3>

<p>メッセージのとおり、GPG 署名の検証に必要な公開鍵が存在しないため。</p>

<h3>3. 対策</h3>

<p>キーサーバに問い合わせればよい。（<code>--recv-keys</code> の値は、エラーメッセージ中 <code>NO_PUBKEY</code> の後ろの値）</p>

<pre><code class="text">$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3FF5FFCAD71472C4
Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.Wv6W1dQY2n --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys 3FF5FFCAD71472C4
gpg: 鍵D71472C4をhkpからサーバーkeyserver.ubuntu.comに要求
gpg: 鍵D71472C4: 公開鍵“QGIS Archive Automatic Signing Key (2015) &lt;qgis-developer@lists.osgeo.org&gt;”を読み込みました
gpg: 処理数の合計: 1
gpg:               読込み: 1  (RSA: 1)
</code></pre>

<p>再度 <code>apt-get update</code> でエラーが発生しないことを確認する。</p>

<hr />

<p>稀に遭遇するエラーなので備忘録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - メモリキャッシュのクリア！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/09/linux-release-memory-caches/"/>
    <updated>2015-10-09T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/09/linux-release-memory-caches</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux でメモリキャッシュをクリアすることについての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Kernel 2.6.16 以降であること。</li>
<li>当方は Linux Mint 17.2(64bit), 搭載メモリ:4GB の環境で動作確認。</li>
</ul>


<h3>1. キャッシュの削除方法</h3>

<p>以下のコマンドは、 root になって実行するか <code>sudo</code> を使用して実行する。</p>

<h4>1-1. ページキャッシュの解放</h4>

<pre><code class="text"># sysctl -w vm.drop_caches=1
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 1 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-2. Slab キャッシュの解放</h4>

<p>（Slab キャッシュとは、ディレクトリやファイルのメタデータ情報を格納する dentry や inode のこと）</p>

<pre><code class="text"># sysctl -w vm.drop_caches=2
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 2 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-3. ページキャッシュと Slab キャッシュの解放</h4>

<pre><code class="text"># sysctl -w vm.drop_caches=3
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 3 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-4. 初期状態について</h4>

<p>あらゆる Web サイト等で「初期状態に戻すには <code>0</code> を設定する」旨の紹介がされている。<br/>
しかし、 RedHat 系では機能するが Debian 系では機能しない。（<code>sysctl</code> も <code>echo</code> も）</p>

<p><code>vm.drop_caches</code> についての説明は <code>man proc</code> で確認できるが、 Debian 系も RedHat 系も <code>0</code> についての説明がされていない。</p>

<p>従って、初期状態には戻す必要はないという結論に至った。（あくまで、個人の判断）<br/>
（とは言え、 <code>cat /proc/sys/vm/drop_caches</code> の値が、マシンを再起動するまでずっと <code>0</code> 以外の状態でいることに疑問を感じる）</p>

<h3>2. 作業の実際</h3>

<p>実際の作業手順は以下のようになる。</p>

<ol>
<li>キャッシュクリア前のメモリ状態を確認。</li>
<li>バッファの内容をディスクに書き込む。</li>
<li>キャッシュをクリア。</li>
<li>キャッシュクリア後のメモリ状態を確認。</li>
</ol>


<p>以下は、ページキャッシュと Slab キャッシュを解放する例。</p>

<pre><code class="text"># free
             total       used       free     shared    buffers     cached
Mem:       4047488    3887116     160372     155764     247452    1104336
-/+ buffers/cache:    2535328    1512160
Swap:      8000508     557132    7443376

# sync

# sysctl -w vm.drop_caches=3
vm.drop_caches = 3

# free
             total       used       free     shared    buffers     cached
Mem:       4047488    2415508    1631980     155764       9856     324056
-/+ buffers/cache:    2081596    1965892
Swap:      8000508     557124    7443384
</code></pre>

<p>物理メモリの空き容量(Mem - free の値）が増えたことを確認する。</p>

<h3>3. 参考サイト</h3>

<ul>
<li><a href="http://linuxjm.osdn.jp/html/LDP_man-pages/man5/proc.5.html" title="Man page of PROC">Man page of PROC</a></li>
</ul>


<hr />

<p>物理メモリの空き容量の減りが気になったら試してみるといいでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - マルチコア CPU で高速圧縮！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/03/linux-archive-speed-up-on-multi-core-cpu/"/>
    <updated>2015-10-03T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/03/linux-archive-speed-up-on-multi-core-cpu</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>通常、 Linux の <code>tar</code> コマンドでファイル等の圧縮を行う場合、 CPU コアを１つしか使用しません。</p>

<p>２つ以上 CPU コアを搭載していることの多い昨今、 CPU コアを全て使用して圧縮を行うと時間の節約になります。</p>

<p>今回、圧縮・解凍をマルチコアで並列に処理してくれる <code>pigz</code> を使用してみました。</p>

<!--more-->


<h3>0.前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Intel Core2Duo CPU E8500 (3.16GHz x 2) での作業を想定。</li>
</ul>


<h3>1. pigz のインストール</h3>

<p>Apt パッケージを使用する（但し、最新版ではない可能性が高い）</p>

<pre><code class="text">$ sudo apt-get install pigz
</code></pre>

<p>もしくは、最新版アーカイブを取得＆展開後、 <code>make</code> して適当な位置に配置してもよい。（但し、当方の環境ではビルドエラーになった）</p>

<pre><code class="text">$ wget http://zlib.net/pigz/pigz-2.3.3.tar.gz
$ tar zxvf pigz-2.3.3.tar.gz
$ cd pigz-2.3.3
$ make
$ sudo mv ./pigz /usr/local/bin/pigz
$ sudo mv ./unpigz /usr/local/bin/unpigz
</code></pre>

<h3>2. pigz インストールの確認</h3>

<pre><code class="text">$ pigz --version
pigz 2.3
</code></pre>

<h3>3. 圧縮</h3>

<p>比較のため、まず <code>tar</code> コマンドで圧縮してみる。<br/>
（圧縮対象は、サブディレクトリ：2層、ファイル数：121,653個、容量：約100MB の &ldquo;test&rdquo; という名称のディレクトリ）</p>

<pre><code class="text">$ time tar zcf test.tar.gz test

real    0m4.711s
user    0m4.402s
sys     0m0.938s
</code></pre>

<p>次に、 pigz 圧縮してみる。<br/>
ディレクトリを再帰的に圧縮できる <code>-r</code> もあるが、これはファイルそれぞれが圧縮されてしまうので、 <code>tar</code> コマンドで一旦ファイルをまとめてから <code>pigz</code> コマンドで圧縮する。また、デフォルトでは全てのプロセッサを使用するが、同時実行スレッド数を指定する <code>-p</code> オプション等もある。</p>

<pre><code class="text">$ time tar c test | pigz &gt; test.tar.gz

real    0m2.987s
user    0m4.624s
sys     0m0.682s
</code></pre>

<p>ちなみに、単純に１つのファイルを圧縮するだけなら <code>pigz -k test.tar.gz</code> でよい（<code>-k</code> は元のファイルを残すオプション）。</p>

<p>さらに、 <code>pigz</code> コマンドを <code>tar</code> コマンドのオプションで使用して圧縮してみる。</p>

<pre><code class="text">$ time tar cf test.tar.gz test --use-compress-program=pigz

real    0m2.970s
user    0m4.542s
sys     0m0.632s
</code></pre>

<h3>4. 解凍</h3>

<p>まず、単純に <code>tar</code> コマンドで圧縮したファイルを解凍してみる。</p>

<pre><code class="text">$ time tar zxf test.tar.gz

real    0m18.441s
user    0m1.813s
sys     0m3.022s
</code></pre>

<p>次に、 <code>pigz</code> で圧縮したファイルを <code>tar</code> コマンドで解凍してみる。</p>

<pre><code class="text">$ time tar xf test.tar.gz --use-compress-program=pigz

real    0m17.526s
user    0m1.193s
sys     0m3.310s
</code></pre>

<h3>5. 所感</h3>

<ul>
<li>コア数 2 の非力な環境でも約 2/3 の速度で圧縮することができたのだが、場合によっては pigz を使用する方が遅くなることもある。</li>
<li>今回、解凍についてはそれほど差が認められなかった。</li>
<li>当然、環境によって結果は異なるだろう。</li>
</ul>


<p>従って、当方は明らかに圧縮の高速化が見込める場合のみ pigz を使用することとした。</p>

<h3>6. 参考サイト</h3>

<ul>
<li><a href="http://zlib.net/pigz/" title="pigz - Parallel gzip">pigz - Parallel gzip</a></li>
</ul>


<hr />

<p>非力な環境では、それほど積極的に使用したいと思うようなコマンドでもありませんでした。</p>

<p>しかし、コアを複数使用して圧縮・解凍ができる、といういことを認識できたことに若干の喜びを感じた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
