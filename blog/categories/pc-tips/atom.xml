<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pc_tips | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/pc-tips/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-10-03T00:36:23+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux - マルチコア CPU で高速圧縮！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/03/linux-archive-speed-up-on-multi-core-cpu/"/>
    <updated>2015-10-03T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/03/linux-archive-speed-up-on-multi-core-cpu</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>通常、 Linux の <code>tar</code> コマンドでファイル等の圧縮を行う場合、 CPU コアを１つしか使用しません。</p>

<p>２つ以上 CPU コアを搭載していることの多い昨今、 CPU コアを全て使用して圧縮を行うと時間の節約になります。</p>

<p>今回、圧縮・解凍をマルチコアで並列に処理してくれる <code>pigz</code> を使用してみました。</p>

<!--more-->


<h3>0.前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Intel Core2Duo CPU E8500 (3.16GHz x 2) での作業を想定。</li>
</ul>


<h3>1. pigz のインストール</h3>

<p>Apt パッケージを使用する（但し、最新版ではない可能性が高い）</p>

<pre><code class="text">$ sudo apt-get install pigz
</code></pre>

<p>もしくは、最新版アーカイブを取得＆展開後、 <code>make</code> して適当な位置に配置してもよい。（但し、当方の環境ではビルドエラーになった）</p>

<pre><code class="text">$ wget http://zlib.net/pigz/pigz-2.3.3.tar.gz
$ tar zxvf pigz-2.3.3.tar.gz
$ cd pigz-2.3.3
$ make
$ sudo mv ./pigz /usr/local/bin/pigz
$ sudo mv ./unpigz /usr/local/bin/unpigz
</code></pre>

<h3>2. pigz インストールの確認</h3>

<pre><code class="text">$ pigz --version
pigz 2.3
</code></pre>

<h3>3. 圧縮</h3>

<p>比較のため、まず <code>tar</code> コマンドで圧縮してみる。<br/>
（圧縮対象は、サブディレクトリ：2層、ファイル数：121,653個、容量：約100MB の &ldquo;test&rdquo; という名称のディレクトリ）</p>

<pre><code class="text">$ time tar zcf test.tar.gz test

real    0m4.711s
user    0m4.402s
sys     0m0.938s
</code></pre>

<p>次に、 pigz 圧縮してみる。<br/>
ディレクトリを再帰的に圧縮できる <code>-r</code> もあるが、これはファイルそれぞれが圧縮されてしまうので、 <code>tar</code> コマンドで一旦ファイルをまとめてから <code>pigz</code> コマンドで圧縮する。また、デフォルトでは全てのプロセッサを使用するが、同時実行スレッド数を指定する <code>-p</code> オプション等もある。</p>

<pre><code class="text">$ time tar c test | pigz &gt; test.tar.gz

real    0m2.987s
user    0m4.624s
sys     0m0.682s
</code></pre>

<p>ちなみに、単純に１つのファイルを圧縮するだけなら <code>pigz -k test.tar.gz</code> でよい（<code>-k</code> は元のファイルを残すオプション）。</p>

<p>さらに、 <code>pigz</code> コマンドを <code>tar</code> コマンドのオプションで使用して圧縮してみる。</p>

<pre><code class="text">$ time tar cf test.tar.gz test --use-compress-program=pigz

real    0m2.970s
user    0m4.542s
sys     0m0.632s
</code></pre>

<h3>4. 解凍</h3>

<p>まず、単純に <code>tar</code> コマンドで圧縮したファイルを解凍してみる。</p>

<pre><code class="text">$ time tar zxf test.tar.gz

real    0m18.441s
user    0m1.813s
sys     0m3.022s
</code></pre>

<p>次に、 <code>pigz</code> で圧縮したファイルを <code>tar</code> コマンドで解凍してみる。</p>

<pre><code class="text">$ time tar xf test.tar.gz --use-compress-program=pigz

real    0m17.526s
user    0m1.193s
sys     0m3.310s
</code></pre>

<h3>5. 所感</h3>

<ul>
<li>コア数 2 の非力な環境でも約 2/3 の速度で圧縮することができたのだが、場合によっては pigz を使用する方が遅くなることもある。</li>
<li>今回、解凍についてはそれほど差が認められなかった。</li>
<li>当然、環境によって結果は異なるだろう。</li>
</ul>


<p>従って、当方は明らかに圧縮の高速化が見込める場合のみ pigz を使用することとした。</p>

<h3>6. 参考サイト</h3>

<ul>
<li><a href="http://zlib.net/pigz/" title="pigz - Parallel gzip">pigz - Parallel gzip</a></li>
</ul>


<hr />

<p>非力な環境では、それほど積極的に使用したいと思うようなコマンドでもありませんでした。</p>

<p>しかし、コアを複数使用して圧縮・解凍ができる、といういことを認識できたことに若干の喜びを感じた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - XML に XSLT を適用して HTML 生成！]]></title>
    <link href="http://komasaru.github.io/blog/2015/09/07/linux-apply-xslt-to-xml-by-xsltproc/"/>
    <updated>2015-09-07T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/09/07/linux-apply-xslt-to-xml-by-xsltproc</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>以前、 Ruby で XML ファイルに XSL テンプレートを適用して HTML を生成する方法を紹介しました。</p>

<ul>
<li><a href="/2013/12/04/ruby-apply-xslt-to-xml/" title="Ruby - XML に XSLT を適用して HTML 生成！">Ruby - XML に XSLT を適用して HTML 生成！</a></li>
</ul>


<p>ただ、 Linux ディストリビューションによってはデフォルトで XML に XSL テンプレートを適用するコマンドがインストールされています。<br/>
わざわざ Ruby を使用しなくてもよいということです。</p>

<p>以下、その使用方法についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>XML に XSL テンプレート適用して HTML ファイルを生成するのに <code>xsltproc</code> コマンドを使用する。</li>
</ul>


<h3>1. xsltproc コマンドのインストール</h3>

<p><code>xsltproc</code> コマンドが未インストールならインストールしておく。</p>

<pre><code class="text">$ sudo apt-get install xsltproc
</code></pre>

<h3>2. XML ファイルの準備</h3>

<p>試験的に使用する XML ファイルを以下のように作成する。（あくまで一例）</p>

<pre><code class="xml test.xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="test.xsl" ?&gt;

&lt;Office&gt;
  &lt;People&gt;
    &lt;Person&gt;
      &lt;No&gt;1234&lt;/No&gt;
      &lt;Name&gt;Ruby 太郎&lt;/Name&gt;
      &lt;Birthday&gt;1980-01-01&lt;/Birthday&gt;
      &lt;Age&gt;33&lt;/Age&gt;
    &lt;/Person&gt;
    &lt;Person&gt;
      &lt;No&gt;2345&lt;/No&gt;
      &lt;Name&gt;XML 二郎&lt;/Name&gt;
      &lt;Birthday&gt;1985-04-15&lt;/Birthday&gt;
      &lt;Age&gt;28&lt;/Age&gt;
    &lt;/Person&gt;
    &lt;Person&gt;
      &lt;No&gt;3456&lt;/No&gt;
      &lt;Name&gt;XSL 花子&lt;/Name&gt;
      &lt;Birthday&gt;1990-09-30&lt;/Birthday&gt;
      &lt;Age&gt;23&lt;/Age&gt;
    &lt;/Person&gt;
  &lt;/People&gt;
&lt;/Office&gt;
</code></pre>

<h3>3. XSL テンプレートファイルの準備</h3>

<p>試験的に使用する XSL テンプレートファイルを以下のように作成する。（あくまで一例）</p>

<pre><code class="xml test.xsl">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
   &lt;xsl:output method="html" encoding="UTF-8"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="Office"&gt;
    &lt;html lang="ja"&gt;
    &lt;body&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="People"&gt;
    &lt;table&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;/table&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="Person"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="No"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="Name"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="Birthday"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>

<h3>4. HTML ファイルの生成</h3>

<p>準備しておいた XML ファイルに XSL テンプレートを適用して HTML ファイルを生成する。</p>

<pre><code class="text">$ xsltproc --output test.html test.xsl test.xml
</code></pre>

<p>※オプションは他にも多数あるので、 <code>xsltproc --help</code> や <code>man xsltproc</code> で確認する。</p>

<h3>5. HTML ファイルの確認</h3>

<p>&ldquo;test.html&rdquo; というファイルが作成されているはずなので、確認してみる。</p>

<pre><code class="html test.html">&lt;html lang="ja"&gt;&lt;body&gt;
  &lt;table&gt;
    &lt;tr&gt;
&lt;td&gt;1234&lt;/td&gt;
&lt;td&gt;Ruby 太郎&lt;/td&gt;
&lt;td&gt;1980-01-01&lt;/td&gt;
&lt;/tr&gt;
    &lt;tr&gt;
&lt;td&gt;2345&lt;/td&gt;
&lt;td&gt;XML 二郎&lt;/td&gt;
&lt;td&gt;1985-04-15&lt;/td&gt;
&lt;/tr&gt;
    &lt;tr&gt;
&lt;td&gt;3456&lt;/td&gt;
&lt;td&gt;XSL 花子&lt;/td&gt;
&lt;td&gt;1990-09-30&lt;/td&gt;
&lt;/tr&gt;
  &lt;/table&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>さらに、この HTML ファイルをブラウザで開いて確認してみる。</p>

<p><img src="/images/2015/09/07/XSLTPROC.png" title="XSLTPROC" alt="XSLTPROC" /></p>

<hr />

<p>単に XML ファイルに XSL テンプレートを適用して HTML ファイルを作成するだけなら、今回の方法が楽でいいかもしれませんね。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - Groonga インストール（by ソースビルド）！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/09/linux-mint-groonga-installation-by-src/"/>
    <updated>2015-08-09T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/09/linux-mint-groonga-installation-by-src</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>オープンソースのカラムストア機能付き全文検索エンジン <a href="http://groonga.org/ja/" title="Groonga - カラムストア機能付き全文検索エンジン">Groonga</a> を、ソースをビルドしてインストールする方法についての記録です。（最後に簡単な使用例も紹介）</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>当記事執筆時点で最新の Groonga 5.0.5 をインストールする。</li>
<li>トークナイザは、デフォルトの N-gram 方式ではなく形態素解析器 MeCab を使用することを想定。</li>
<li>ここでは、全文検索がどういうものかという説明はしない。</li>
<li>以下の説明内で出力するデータは、可読性を考慮して整形している。</li>
</ul>


<h3>1. 依存パッケージのインストール</h3>

<pre><code class="text">$ sudo apt-get -y install wget tar build-essential \
&gt; zlib1g-dev liblzo2-dev libmsgpack-dev \
&gt; libzmq-dev libevent-dev libmecab-dev
</code></pre>

<h3>2. アーカーブソースの取得</h3>

<p>アーカイブファイルをダウンロード後、展開する。</p>

<pre><code class="text">$ wget http://packages.groonga.org/source/groonga/groonga-5.0.5.tar.gz
$ tar zxvf groonga-5.0.5.tar.gz
</code></pre>

<h3>3. ビルド＆インストール</h3>

<p><code>configure</code>, <code>make</code>, <code>make install</code> する。</p>

<pre><code class="text">$ cd groonga-5.0.5
$ ./configure
$ make -j$(grep '^processor' /proc/cpuinfo | wc -l)
$ sudo make install
</code></pre>

<ul>
<li><code>make</code> の <code>-j$(grep '^processor' /proc/cpuinfo | wc -l)</code> の部分はプロセッサ数が明確なら <code>-j4</code> のように指定してもよいし、速度を気にしないのなら単に <code>make</code> のみでもよい。</li>
<li><code>configure</code> オプションについては <a href="http://groonga.org/ja/docs/install/others.html#source-configure">configure</a> を参照。</li>
</ul>


<p>そして、インストールされたかバージョンを表示して確認してみる。</p>

<pre><code class="text">$ groonga --version
groonga 5.0.5 [linux-gnu,x86_64,utf8,match-escalation-threshold=0,nfkc,mecab,msgpack,onigmo,zlib,epoll]

configure options: &lt;&gt;
</code></pre>

<h3>4. 動作確認</h3>

<p>簡単に動作確認してみる。（パスは適宜変更）<br/>
以下は、都道府県名のローマ字表記を <code>_key</code>、都道府県名の漢字表記を <code>name</code> として登録する例。（簡易都道府県名データベース）</p>

<h4>4-1. データベースの作成</h4>

<pre><code class="text">$ mkdir ~/groonga-db
$ groonga -n ~/groonga-db/test.db
</code></pre>

<p>データベース作成後は自動で対話モードに入るが、手動で対話モードへ入るには以下のようにする。</p>

<pre><code class="text">$ groonga ~/groonga-db/test.db
</code></pre>

<h4>4-2. テーブルの作成</h4>

<pre><code class="text">&gt; table_create --name Prefs --flags TABLE_HASH_KEY --key_type ShortText
[
  [0,1436411689.75983,0.0292973518371582],
  true
]
</code></pre>

<h4>4-3. テーブルの表示</h4>

<pre><code>&gt; select --table Prefs
[
  [0,1436411701.50367,0.000922203063964844],
  [
    [
      [0],
      [
        ["_id","UInt32"],
        ["_key","ShortText"]
      ]
    ]
  ]
]
</code></pre>

<h4>4-4. カラムの作成</h4>

<pre><code class="text">&gt; column_create --table Prefs --name name --type ShortText
[
  [0,1436411764.36768,0.0517301559448242],
  true
]

&gt; select --table Prefs
[
  [0,1436411783.16738,0.000133037567138672],
  [
    [
      [0],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["name","ShortText"]
      ]
    ]
  ]
]
</code></pre>

<h4>4-5. データのロード</h4>

<pre><code class="text">&gt; load --table Prefs
[
  {"_key":"Hokkaido","name":"北海道"},
  {"_key":"Aomoriken","name":"青森県"},
           :
  ====&lt; 途中省略 &gt;====
           :
  {"_key":"Kagoshimaken","name":"鹿児島県"},
  {"_key":"Okinawaken","name":"沖縄県"},
]
</code></pre>

<p>もしくは、以下のようにコマンドラインから JSON 形式で作成したファイルを取り込んでもよい。</p>

<pre><code class="text load.grn">load --table Prefs
[
  {"_key":"Hokkaido","name":"北海道"},
  {"_key":"Aomoriken","name":"青森県"},
           :
  ====&lt; 途中省略 &gt;====
           :
  {"_key":"Kagoshimaken","name":"鹿児島県"},
  {"_key":"Okinawaken","name":"沖縄県"},
]
</code></pre>

<pre><code class="text">$ groonga ~/groonga-db/test.db &lt; load.grn
[[0,1436415458.66362,0.00340938568115234],47]
</code></pre>

<h4>4-6. レコードの取得</h4>

<pre><code class="text "全レコードを取得（但し、先頭10件）"">select --table Prefs
[
  [0,1436415521.50463,0.00343823432922363],
  [
    [
      [47],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["name","ShortText"]
      ],
      [1,"Hokkaido","北海道"],
      [2,"Aomoriken","青森県"],
      [3,"Iwateken","岩手県"],
      [4,"Miyagiken","宮城県"],
      [5,"Akitaken","秋田県"],
      [6,"Yamagataken","山形県"],
      [7,"Fukushimaken","福島県"],
      [8,"Ibarakiken","茨城県"],
      [9,"Tochigiken","栃木県"],
      [10,"Gunmaken","群馬県"]
    ]
  ]
]
</code></pre>

<pre><code class="text "ID が 32 のレコードを取得"">&gt; select --table Prefs --query _id:32
[
  [0,1436415572.03281,0.0471560955047607],
  [
    [
      [1],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["name","ShortText"]
      ],
      [32,"Shimaneken","島根県"]
    ]
  ]
]
</code></pre>

<pre><code class="text "KEY が shimaneken のレコードを取得"">&gt; select --table Prefs --query '_key:"Shimaneken"'
[
  [0,1436415572.03281,0.0471560955047607],
  [
    [
      [1],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["name","ShortText"]
      ],
      [32,"Shimaneken","島根県"]
    ]
  ]
</code></pre>

<h4>4-7. 全文検索用の語彙表の作成</h4>

<p>高速な全文検索を実現するためには転置インデックスが必要であるので、転置インデックスとして使用するテーブルを作成する。（トークナイザとして MeCab を使用する）</p>

<p>辞書テーブルの作成は以下のようにする。</p>

<pre><code class="text 辞書テーブルの作成">&gt; table_create --name Terms --flags TABLE_PAT_KEY|KEY_NORMALIZE --key_type ShortText --default_tokenizer TokenMecab
[[0,1436416480.43314,0.0687055587768555],true]
</code></pre>

<p>辞書テーブルへのカラムの作成は以下のようにする。</p>

<pre><code class="text 辞書テーブルへのカラムの作成">&gt; column_create --table Terms --name pref_name --flags COLUMN_INDEX|WITH_POSITION --type Prefs --source name
[[0,1436416570.78517,0.964933156967163],true]
</code></pre>

<p>辞書テーブルの確認は以下のようにする。</p>

<pre><code class="text 辞書テーブルの確認">&gt; select --table Terms
[
  [0,1436416592.4811,0.000155210494995117],
  [
    [
      [50],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["pref_name","UInt32"]
      ],
      [1,"三重",1],
      [2,"京都",1],
      [3,"佐賀",1],
      [4,"兵庫",1],
      [5,"北海道",1],
      [6,"千葉",1],
      [7,"和歌山",1],
      [8,"埼玉",1],
      [9,"大分",1],
      [10,"大阪",1]
    ]
  ]
]
</code></pre>

<p>テーブルの検索は以下のようにする。</p>

<pre><code class="text テーブルの検索">&gt; select --table Prefs --query name:@府
[
  [0,1436416671.28152,0.000936269760131836],
  [
    [
      [2],
      [
        ["_id","UInt32"],
        ["_key","ShortText"],
        ["name","ShortText"]
      ],
      [26,"Kyotofu","京都府"],
      [27,"Osakafu","大阪府"]
    ]
  ]
]
</code></pre>

<h4>4-8. 対話モードの終了</h4>

<pre><code class="text">&gt; quit
</code></pre>

<h3>5. 参考サイト</h3>

<ul>
<li><a href="http://groonga.org/ja/" title="Groonga - カラムストア機能付き全文検索エンジン">Groonga - カラムストア機能付き全文検索エンジン</a></li>
</ul>


<hr />

<p>慣れないうちは Groonga を単体で扱うのは若干面倒に感じます。</p>

<p>当方は、Rroonga（Groonga の機能を Ruby から利用するためのライブラリ）や Mroonga（Groonga をベースとした MySQL のストレージエンジン）を使用することも考えています。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tmux - Window, Pane, Session 自動保存プラグイン！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/06/tmux-automatic-session-preservation/"/>
    <updated>2015-08-06T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/06/tmux-automatic-session-preservation</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>ターミナルマルチプレクサ（仮想端末マネージャ） tmux の Window, Pane, Session 等を保存（自動保存）するプラグインをインストールする方法についての記録です。</p>

<p>Window, Pane, Session 等を保存するプラグインは tmux-resurrect で、それを自動化するプラグインは tmux-continuum です。<br/>
また、プラグインの管理には tpm(Tmux Plugin Manager)を使用します。<br/>
（以前は tmux-resurrect を自動化するプラグインは tmux-resurrect-auto でしたが、現在は tmux-continuum に改名されています。tmux-resurrect-auto も使用できますが）</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>tmux 2.1 での作業を想定。</li>
<li>Git がインストール済みであること。</li>
<li>tpm(Tmux Plugin Manager) で tmux プラグインを管理することを想定。<br/>
（tpm を使用せず手動でインストールすることも可能）</li>
</ul>


<h3>1. tpm のインストール</h3>

<p>tmux プラグインの管理に tpm(Tmux Plugin Manager) を使用するのでインストールする。</p>

<pre><code class="text">$ git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
</code></pre>

<h3>2. tmux.conf の編集</h3>

<p>&ldquo;~/.tmux.conf&rdquo; に以下の記述を追記する。</p>

<p>``` bash ~/.tmux.conf
set-option -g @tpm_plugins &lsquo;  \
  tmux-plugins/tpm            \
  tmux-plugins/tmux-resurrect \
  tmux-plugins/tmux-continuum \
&rsquo;
set-option -g @continuum-save-interval &lsquo;60&rsquo;
set-option -g @resurrect-processes &lsquo;ssh -p 9999 hoge&rsquo;
set-option -g @resurrect-strategy-vim &lsquo;session&rsquo;</p>

<p>run-shell &lsquo;~/.tmux/plugins/tpm/tpm&rsquo;
<code>``
*</code>set-option<code>は</code>set<code>で代用可。
*</code>set-option -g @continuum-save-interval<code>でセッションを自動保存する間隔を指定する。  
   非指定時のデフォルトは</code>15<code>分。</code>0<code>で自動保存の無効化。
*</code>set-option -g @resurrect-processes<code>で保存したいセッションを指定する。  
  （上記の例は "hoge" ホストへポート 9999 で SSH 接続したセッションを保存する例）
*</code>set-option -g @resurrect-strategy-vim &lsquo;session&rsquo;` で Vim のセッションを保存する。</p>

<h3>3. プラグインのインストール</h3>

<p>tmux 上で Prefix 押下後に <code>I</code> を押下する。（<code>i</code> ではなく <code>I</code>）</p>

<h3>4. 動作確認</h3>

<p>Prefix + CTRL-s で Window, Pane, Session 等の状態を保存、Prefix + CTLR-r でWindow, Pane, Session 等の状態を復元できるので、「保存→マシン再行動→復元」と試してみる。</p>

<p>tmux-continuum はデフォルトでは 60 分間隔で状態を保存するようなので、その辺りの動作も確認しておく。</p>

<p>ちなみに、状態は &ldquo;~/.tmux/resurrect&rdquo; ディレクトリ配下にテキストファイルで保存される。</p>

<hr />

<p>これで、マシンを起動する度に Window, Pane, Session 等を手動で復元する手間が省けます。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - tmux 2.1 のインストール（by ソースビルド）！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/03/linux-mint-tmux-installation-by-src/"/>
    <updated>2015-08-03T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/03/linux-mint-tmux-installation-by-src</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>ターミナルマルチプレクサ（仮想端末マネージャ）である tmux(Terminal MUltipleXer) の最新版を Linux Mint へインストールする方法についての記録です。</p>

<p>これまで Apt パッケージでインストールした tmux 1.8 を使用していました。<br/>
しかし、使用したいプラグインが tmux 1.9 未満ではインストールできないため、最新版の 2.1 をソースビルドでインストールすることとしました。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Git でソースを取得するため Git がインストール済みであること。</li>
<li>当記事執筆時点で最新の tmux 2.1 をインストールする。</li>
<li>Apt でインストールしていた tmux 1.8 はアンインストールしておく。</li>
</ul>


<h3>1. libevent-dev のインストール</h3>

<p>libevent-dev 2.x のパッケージが必要なので未インストールならインストールする。<br/>
（以前は Apt では 2.x はインストールできずソースをビルドしてインストールする必要があったが、今は Apt で 2.x がインストール可能）</p>

<pre><code class="text">$ sudo apt-get install libevent-dev
</code></pre>

<h3>2. tmux のインストール</h3>

<p>Git でソースを <code>clone</code> して、 <code>configure</code>, <code>make</code>, <code>make install</code> する。<br/>
（但し、<code>configure</code> 実行前に <code>autogen.sh</code> の実行が必要）</p>

<pre><code class="text">$ git clone https://github.com/tmux/tmux.git
$ cd tmux
$ autogen.sh
$ ./configure
$ make
$ sudo make install
</code></pre>

<h3>3. tmux インストールの確認</h3>

<p>端末から <code>tmux</code> と入力・実行して tmux が起動すればよい。<br/>
また、tmux コンソールが起動後にバージョンも確認してみる。</p>

<pre><code class="text">$ tmux -V
tmux 2.1
</code></pre>

<p>もしも、 tmux 起動時に以下のようなメッセージが出力されて起動しない場合は、</p>

<pre><code class="text">protocol version mismatch (client 8, server 7)
</code></pre>

<p>古いバージョンの tmux サーバのセッションが残っているため。<br/>
その場合は、以下のように起動中の tmux プロセスを kill すればよい。（厳密に PID をチェックして <code>kill</code> してもよい）</p>

<pre><code class="text">$ killall tmux
</code></pre>

<h3>4. その他</h3>

<p>その他、各種設定を行う。</p>

<p>当ブログ過去記事も参照。</p>

<ul>
<li><a href="http://www.mk-mode.com/octopress/tags/tmux/" title="Tag:tmux - mk-mode BLOG">Tag:tmux - mk-mode BLOG</a></li>
</ul>


<p>一つだけ注意するとするなら、マウスモードの指定方法。<br/>
古いバージョンでは &ldquo;~/.tmux.conf&rdquo; で以下のように指定していたが、</p>

<p><code>bash ~/.tmux.conf
set-option -g mode-mouse on
set-option -g mouse-select-pane on
set-option -g mouse-select-window on
set-option -g mouse-resize-pane on
</code></p>

<p>今のバージョンでは以下のように１行のみ指定すればよい。</p>

<p><code>bash ~/.tmux.conf
set-option -g mouse on
</code></p>

<p>但し、これだけではマウスでのスクロールができないので、以下のような記述も追加する。</p>

<p><code>bash ~/.tmux.conf
bind-key -n WheelUpPane if-shell -Ft= "#{?pane_in_mode,1,#{alternate_on}}" "send-keys -M" "copy-mode"
</code></p>

<p>（<code>set-option</code> = <code>set</code>, <code>bind-key</code> = <code>bind</code>, <code>send-keys</code> = <code>send</code> とエイリアスされているので、置き換えてもよい）</p>

<h3>参考サイト</h3>

<ul>
<li><a href="http://tmux.github.io/" title="tmux">tmux</a></li>
</ul>


<hr />

<p>これで、使用したかった tmux プラグインが使用できるでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
