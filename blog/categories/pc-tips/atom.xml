<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pc_tips | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/pc-tips/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2016-01-02T00:07:48+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux - マシン起動時にディレクトリ・ファイルを自動作成！]]></title>
    <link href="http://komasaru.github.io/blog/2015/12/08/linux-dir-file-automatic-creation-on-boot/"/>
    <updated>2015-12-08T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/12/08/linux-dir-file-automatic-creation-on-boot</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux で、マシン起動時に自動でディレクトリやファイルを作成する方法についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.7(i386) での作業を想定。（他の Linux ディストリビューションでも同様のはず）</li>
</ul>


<h3>1. はじめに</h3>

<ul>
<li>今回の作業は、 <code>/etc/tmpfiles.d/*.conf</code> ファイルを作成することで実現する。
（環境によっては、 <code>/run/tmpfiles.d/*.conf</code>, <code>/usr/lib/tmpfiles.d/*.conf</code> ファイル）</li>
<li><code>/etc/tmpfiles.d/*.conf</code> ファイル内の書式は以下のとおり。（詳細は「<a href="http://www.unix.com/man-page/centos/5/tmpfiles.d/" title="CentOS 7.0 - man page for tmpfiles.d (centos section 5) - Unix &amp; Linux Commands">参考サイト</a>」参照<br/>
<code>Type Path Mode UID GID Age Argument</code></li>
</ul>


<h3>2. 作成例</h3>

<p>当方が使用する頻度が高いもののみについて、作成例を挙げる。</p>

<h4>2-1. ディレクトリが存在しなければ作成する例</h4>

<p>「ディレクトリ：/tmp/test_dir, パーミッション：1777, 所有者：root, グループ：root, 有効期限：５日」でディレクトリを作成する例。</p>

<pre><code class="bash /etc/tmpfiles.d/test_1.conf">d /tmp/test_dir 1777 root root 5d
</code></pre>

<h4>2-2. ディレクトリが存在しなければ作成し、存在していれば空にする例</h4>

<p>「ディレクトリ：/home/foo/test_dir, パーミッション：0755, 所有者：root, グループ：root, 有効期限：無限」でディレクトリを作成する例。</p>

<pre><code class="bash /etc/tmpfiles.d/test_2.conf">D /home/foo/test_dir 0755 root root -
</code></pre>

<h4>2-3. ファイルが存在しなければ作成する例</h4>

<p>「ファイル：/home/foo/test.txt, パーミッション：0777, 所有者：root, グループ：root, 有効期限：無限、ファイル内容：空」でファイルを作成する例。</p>

<pre><code class="bash /etc/tmpfiles.d/test_3.conf">f /home/foo/test.txt 0777 root root -
</code></pre>

<h4>2-4. ファイルが存在しなければ作成し、存在していれば空にする例</h4>

<p>「ファイル：/home/foo/test.txt, パーミッション：0777, 所有者：root, グループ：root, 有効期限：無限、ファイル内容："This is a tmpfiles.d test!&ldquo;」でファイルを作成する例。</p>

<pre><code class="bash /etc/tmpfiles.d/test_4.conf">F /home/foo/test.txt 0777 root root - "This is a tmpfiles.d test!"
</code></pre>

<h3>3. 参考サイト</h3>

<ul>
<li><a href="http://www.unix.com/man-page/centos/5/tmpfiles.d/" title="CentOS 7.0 - man page for tmpfiles.d (centos section 5) - Unix &amp; Linux Commands">CentOS 7.0 - man page for tmpfiles.d (centos section 5) - Unix &amp; Linux Commands</a></li>
</ul>


<hr />

<p>意外とよく使用する機能だけど、使用方法について説明しているサイトがあまりないので、備忘録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - MTU 最適値の導出！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/26/linux-mtu-best-effort/"/>
    <updated>2015-11-26T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/26/linux-mtu-best-effort</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux で最適な MTU 値を導出する方法についての備忘録です。</p>

<!--more-->


<h3>1. MTU について</h3>

<p>MTU とは Maximum Transmission Unit の略で、ネットワーク上において１フレーム（１回の転送）で送信可能な IP パケットの最大サイズのこと。<br/>
（このサイズは IP ヘッダ ＋ ICMP ヘッダ ＋ データのサイズ）</p>

<h3>2. MTU 現在値の確認</h3>

<pre><code class="text">$ ifconfig
ifconfig
eth0      Link encap:イーサネット  ハードウェアアドレス XX:XX:XX:XX:XX:XX
          inetアドレス:192.168.XXX.XXX  ブロードキャスト:192.168.XXX.255  マスク:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  メトリック:1
          RXパケット:49793411 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:30012458 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:1000
          RXバイト:23207684202 (23.2 GB)  TXバイト:21221894153 (21.2 GB)
          割り込み:17

lo        Link encap:ローカルループバック
          inetアドレス:127.0.0.1  マスク:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  メトリック:1
          RXパケット:27117491 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:27117491 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:0
          RXバイト:32672340989 (32.6 GB)  TXバイト:32672340989 (32.6 GB)
</code></pre>

<p>eth0 の MTU 値が <code>1500</code> となっている。</p>

<h3>3. MTU 最適値の導出</h3>

<p>要は、様々なサイズのパケット（データ）を断片化せずに送信してみてロスしない最大値を求めればよい。<br/>
但し、「IP ヘッダ ＋ ICMP ヘッダ」が「28 バイト」あるので、 MTU に設定する値は +28 したものになる。
（送信先は存在する URL ならどこでもよい）</p>

<p>では、実際に導出作業を行なってみる。（大体の目星をつけて作業を行うとよいだろう）</p>

<p>以下では <code>ping</code> コマンドを使用するがオプションは次のとおり。</p>

<ul>
<li><code>-c 1</code> は、リクエスト回数を１回に設定するオプション</li>
<li><code>-s 9999</code> は、送信パケットサイズを 9999 に設定するオプション</li>
<li><code>-M do</code> は、パケットの断片化を行わないオプション</li>
</ul>


<p>まず、パケットサイズ 1400 バイトで送信してみる。</p>

<pre><code class="text"># ping -c 1 -s 1400 -M do www.linuxmint.com
PING www.linuxmint.com (213.175.215.218) 1400(1428) bytes of data.
1408 bytes from forums.linuxmint.com (213.175.215.218): icmp_seq=1 ttl=49 time=308 ms

--- www.linuxmint.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 308.674/308.674/308.674/0.000 ms
</code></pre>

<p><code>1 received, 0% packet loss</code> なので、正常に送信できているということ。</p>

<p>次に、パケットサイズ 1500 バイトで送信してみる。</p>

<pre><code class="text">$ ping -c 1 -s 1500 -M do www.linuxmint.com
PING www.linuxmint.com (213.175.215.218) 1500(1528) bytes of data.
ping: local error: Message too long, mtu=1454

--- www.linuxmint.com ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
</code></pre>

<p><code>0 received, +1 errors, 100% packet loss</code> なので、送信に失敗しているということ。</p>

<p>このように、パケットサイズを変更しながら絞り込んでいく。</p>

<p>今回の当方の環境の場合、パケットサイズ「1426 バイト」が正常に送信できる最大値であった。</p>

<p>よって、 MTU 値は IP ヘッダ ＋ ICMP ヘッダの 28 バイトをプラスした「1454 バイト」となる。<br/>
（ちなみに、この値は今回の当方の環境ではよく知られている最適な MTU 値）</p>

<h3>4. MTU 値の変更</h3>

<p>後は、MTU 値を前項で導出した値に変更すればよい。</p>

<pre><code class="text">$ ifconfig eth0 mtu 1454
</code></pre>

<p>但し、この設定は一時的なものなのでマシンを再起動すると元に戻ってしまう。</p>

<p>恒久的に変更するには、ネットワーク接続の編集の画面で MTU 値を「自動（もしくは、何らかの数値）」から変更、もしくは設定ファイル &ldquo;/etc/NetworkManager/system-connections/Wired\ connection\ 1&rdquo; 等を編集し、再起動（ネットワーク再接続）する。（Linux Mint 等の場合）</p>

<p>ちなみに、 CentOS の CUI ベースなら &ldquo;/etc/sysconfig/network-scripts/ifcfg-eth0&rdquo; 等を編集して再起動する。</p>

<hr />

<p>それほどネットワーク周りが改善されたと体感できないかもしれませんが、最適化しないよりはした方がよいでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - Apt パッケージリストアップデートで GPG 公開鍵の期限切れエラー！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/21/linux-mint-apt-gpg-pubkey-expired-error/"/>
    <updated>2015-11-21T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/21/linux-mint-apt-gpg-pubkey-expired-error</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux Mint で <code>apt-get update</code> すると公開鍵期限切れのエラーが発生するようになりました。</p>

<p>（以前「<a href="/2015/10/14/linux-mint-apt-gpg-pubkey-error/" title="Linux Mint - apt-get update で GPG 公開鍵エラー！">Linux Mint - apt-get update で GPG 公開鍵エラー！</a>」という記事も公開しています。参考までに）</p>

<p>以下、現象・原因・対策についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
</ul>


<h3>1. 現象</h3>

<p><code>sudo apt-get update</code> を実行すると以下のようなエラーが発生する。（アップデートマネージャでも同様）</p>

<pre><code class="text">W: GPG エラー: http://cran.ism.ac.jp trusty/ Release: 以下の署名が無効です: KEYEXPIRED 1445181253 KEYEXPIRED 1445181253 KEYEXPIRED 1445181253,
</code></pre>

<p>（ちなみに、今回の現象は統計解析用プログラミング言語 R のパッケージにに関するもの）</p>

<h3>2. 原因</h3>

<p>エラーメッセージに記載されているとおり、 <code>1445181253</code> というキーが <code>KEYEXPIRED</code>（期限切れ）になっているため。</p>

<h3>3. 対策</h3>

<p>まず、キーの状態を確認してみる。</p>

<pre><code class="text">$ apt-key list

pub   2048R/E084DAB9 2010-10-19 [満了: 2015-10-18]
uid                  Michael Rutter &lt;marutter@gmail.com&gt;
</code></pre>

<p>確かに期限が切れている。</p>

<p>従って、キーサーバに問い合わせて、公開鍵を再取得すればよい。</p>

<pre><code class="text">$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9
Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.UCCHrlWZQw --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys E084DAB9
gpg: 鍵E084DAB9をhkpからサーバーkeyserver.ubuntu.comに要求
gpg: 鍵E084DAB9:“Michael Rutter &lt;marutter@gmail.com&gt;”新しい署名を2個
gpg: 処理数の合計: 1
gpg:         新しい署名: 2
</code></pre>

<p>再度、キーの状態を確認してみる。</p>

<pre><code class="text">$ apt-key list

pub   2048R/E084DAB9 2010-10-19 [満了: 2020-10-16]
uid                  Michael Rutter &lt;marutter@gmail.com&gt;
sub   2048R/1CFF3E8F 2010-10-19 [満了: 2020-10-16]
</code></pre>

<p>満了日が延長された。</p>

<p>これで、正常に <code>sudo apt-get update</code> が実行できるはず。</p>

<hr />

<p>めったに遭遇しない事象なので、後学のために記録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Mint - apt-get update で GPG 公開鍵エラー！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/14/linux-mint-apt-gpg-pubkey-error/"/>
    <updated>2015-10-14T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/14/linux-mint-apt-gpg-pubkey-error</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux Mint で、いつしか Apt パッケージの一覧を更新しようとすると GPG 公開鍵エラーが発生するようになりました。</p>

<p>以下、現象・原因・対策についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) を想定。</li>
</ul>


<h3>1. 現象</h3>

<p>Apt パッケージ一覧をアップデートした際に以下のようなエラーが発生する。（<code>W</code> なので分類としては「警告」でしょうが）<br/>
（以下は QGIS というパッケージの部分で発生した例で、実際のメッセージは１行）</p>

<pre><code class="text">$ sudo apt-get update

====&lt; 途中省略 &gt;====

W: GPG エラー: http://qgis.org trusty InRelease: 
公開鍵を利用できないため、以下の署名は検証できませんでした: NO_PUBKEY 3FF5FFCAD71472C4

====&lt; 以下省略 &gt;====
</code></pre>

<p>当然ながら、アップデートマネージャでも同じエラーが発生する。</p>

<h3>2. 原因</h3>

<p>メッセージのとおり、GPG 署名の検証に必要な公開鍵が存在しないため。</p>

<h3>3. 対策</h3>

<p>キーサーバに問い合わせればよい。（<code>--recv-keys</code> の値は、エラーメッセージ中 <code>NO_PUBKEY</code> の後ろの値）</p>

<pre><code class="text">$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3FF5FFCAD71472C4
Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.Wv6W1dQY2n --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys 3FF5FFCAD71472C4
gpg: 鍵D71472C4をhkpからサーバーkeyserver.ubuntu.comに要求
gpg: 鍵D71472C4: 公開鍵“QGIS Archive Automatic Signing Key (2015) &lt;qgis-developer@lists.osgeo.org&gt;”を読み込みました
gpg: 処理数の合計: 1
gpg:               読込み: 1  (RSA: 1)
</code></pre>

<p>再度 <code>apt-get update</code> でエラーが発生しないことを確認する。</p>

<hr />

<p>稀に遭遇するエラーなので備忘録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - メモリキャッシュのクリア！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/09/linux-release-memory-caches/"/>
    <updated>2015-10-09T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/09/linux-release-memory-caches</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux でメモリキャッシュをクリアすることについての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Kernel 2.6.16 以降であること。</li>
<li>当方は Linux Mint 17.2(64bit), 搭載メモリ:4GB の環境で動作確認。</li>
</ul>


<h3>1. キャッシュの削除方法</h3>

<p>以下のコマンドは、 root になって実行するか <code>sudo</code> を使用して実行する。</p>

<h4>1-1. ページキャッシュの解放</h4>

<pre><code class="text"># sysctl -w vm.drop_caches=1
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 1 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-2. Slab キャッシュの解放</h4>

<p>（Slab キャッシュとは、ディレクトリやファイルのメタデータ情報を格納する dentry や inode のこと）</p>

<pre><code class="text"># sysctl -w vm.drop_caches=2
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 2 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-3. ページキャッシュと Slab キャッシュの解放</h4>

<pre><code class="text"># sysctl -w vm.drop_caches=3
</code></pre>

<p>もしくは、</p>

<pre><code class="text"># echo 3 &gt; /proc/sys/vm/drop_caches
</code></pre>

<h4>1-4. 初期状態について</h4>

<p>あらゆる Web サイト等で「初期状態に戻すには <code>0</code> を設定する」旨の紹介がされている。<br/>
しかし、 RedHat 系では機能するが Debian 系では機能しない。（<code>sysctl</code> も <code>echo</code> も）</p>

<p><code>vm.drop_caches</code> についての説明は <code>man proc</code> で確認できるが、 Debian 系も RedHat 系も <code>0</code> についての説明がされていない。</p>

<p>従って、初期状態には戻す必要はないという結論に至った。（あくまで、個人の判断）<br/>
（とは言え、 <code>cat /proc/sys/vm/drop_caches</code> の値が、マシンを再起動するまでずっと <code>0</code> 以外の状態でいることに疑問を感じる）</p>

<h3>2. 作業の実際</h3>

<p>実際の作業手順は以下のようになる。</p>

<ol>
<li>キャッシュクリア前のメモリ状態を確認。</li>
<li>バッファの内容をディスクに書き込む。</li>
<li>キャッシュをクリア。</li>
<li>キャッシュクリア後のメモリ状態を確認。</li>
</ol>


<p>以下は、ページキャッシュと Slab キャッシュを解放する例。</p>

<pre><code class="text"># free
             total       used       free     shared    buffers     cached
Mem:       4047488    3887116     160372     155764     247452    1104336
-/+ buffers/cache:    2535328    1512160
Swap:      8000508     557132    7443376

# sync

# sysctl -w vm.drop_caches=3
vm.drop_caches = 3

# free
             total       used       free     shared    buffers     cached
Mem:       4047488    2415508    1631980     155764       9856     324056
-/+ buffers/cache:    2081596    1965892
Swap:      8000508     557124    7443384
</code></pre>

<p>物理メモリの空き容量(Mem - free の値）が増えたことを確認する。</p>

<h3>3. 参考サイト</h3>

<ul>
<li><a href="http://linuxjm.osdn.jp/html/LDP_man-pages/man5/proc.5.html" title="Man page of PROC">Man page of PROC</a></li>
</ul>


<hr />

<p>物理メモリの空き容量の減りが気になったら試してみるといいでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
