<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: サーバ構築 | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/サーバ構築/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-11-15T12:44:14+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux - Disk の IOPS の確認！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/15/linux-check-disk-iops/"/>
    <updated>2015-11-15T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/15/linux-check-disk-iops</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>今回は、Linux OS でハードディスクが単位時間当たりどれくらい入出力要求をこなしているのか？を確認する方法についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CPU と入出力装置の負荷を確認するための <code>iostat</code> コマンドを使用する。</li>
<li>Linux Mint や Debian 等はデフォルトではインストールされていないかもしれない。<br/>
その場合は、 <code>apt-get install sysstat</code> 等でインストールする。</li>
</ul>


<h3>1. IOPS について</h3>

<p>まず &ldquo;IOPS&rdquo; とは、記憶装置がある条件下で1秒間で読み込み・書き込みができる回数のことで、 &ldquo;Input/Output Per Second&rdquo; の略である。</p>

<h3>2. コマンドの実行</h3>

<p>以下のようにコマンドを実行する。</p>

<pre><code class="text"># iosat -dx
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda              51.59    64.81   72.45   15.82    17.47    44.00     0.70     0.31    3.47   0.89   7.82
</code></pre>

<ul>
<li><code>-d</code> はデバイスの利用統計のみを表示するオプション。</li>
<li><code>-x</code> は指定したデバイスの統計を追加表示するオプション。<br/>
（デバイス名を指定しなかった場合は、 &ldquo;/proc/partitions&rdquo; に登録されている全てのデバイスについて表示される）</li>
<li><code>iostat -dx 3 10</code> のように実行すると、3秒間隔で10回表示する。</li>
<li>出力項目について

<ul>
<li><code>rrqm/s</code> &hellip; 結合したデバイスの入力要求の数</li>
<li><code>wrqm/s</code> &hellip; 結合したデバイスの出力要求の数</li>
<li><code>r/s</code> &hellip; 1秒間にデバイスに出力された入力要求の数</li>
<li><code>w/s</code> &hellip; 1秒間にデバイスに出力された出力要求の数</li>
<li><code>rsec/s</code> &hellip; 1秒間にデバイスから読み込んだセクタ数</li>
<li><code>wsec/s</code> &hellip; 1秒間にデバイスへ書き込んだセクタ数</li>
<li><code>avgrq-sz</code> &hellip; デバイスに出された入出力要求の平均サイズ</li>
<li><code>avgqu-sz</code> &hellip; デバイスに出された入出力要求のキューの長さの平均</li>
<li><code>await</code> &hellip; デバイスに出された入出力要求が受け取られるまでの平均時間</li>
<li><code>svctm</code> &hellip; デバイスに出された入出力要求の平均処理時間</li>
<li><code>%util</code> &hellip; デバイスの入出力要求を出す間に使用したCPUの平均時間</li>
</ul>
</li>
</ul>


<p>ちなみに、 <code>-x</code> オプションを使用しない場合は以下のように出力される。</p>

<pre><code class="text"># iostat -d
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda              88.28        17.98        44.05  249632216  611679582
</code></pre>

<ul>
<li>出力項目について

<ul>
<li><code>tps</code> &hellip; デバイスへの入出力要求の数</li>
<li><code>Blk_read/s</code> &hellip; デバイスから読み込んだブロック数の平均</li>
<li><code>Blk_wrtn/s</code> &hellip; デバイスへ書き込んだブロック数の平均</li>
<li><code>Blk_read</code> &hellip; 読み込んだブロック数</li>
<li><code>Blk_wrtn</code> &hellip; 書き込んだブロック数</li>
</ul>
</li>
</ul>


<p>更には、 <code>-c</code> オプションで CPU の利用統計が確認できる。</p>

<pre><code class="text"># iostat -c
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          11.57    2.39    2.35   31.88    0.00   51.81
</code></pre>

<ul>
<li>出力項目について

<ul>
<li><code>%user</code> &hellip; ユーザレベルでのCPU使用率(%)</li>
<li><code>%nice</code> &hellip; ユーザレベルで、優先的にCPUを使用したときのCPU使用率(%)</li>
<li><code>%system</code> &hellip; システムレベルでのCPU使用率(%)</li>
<li><code>%iowait</code> &hellip; CPU総時間当たりのI/O待ち時間率(%)</li>
<li><code>%steal</code> &hellip; ゲストOSがリソース要求を行ったにもかかわらずCPUリソースを割り当ててもらえなかった時間の割合(%)</li>
<li><code>%idle</code> &hellip; CPUのアイドル率(%)</li>
</ul>
</li>
</ul>


<p>そして、<code>iostat</code> をオプションを全く指定しないで実行するのは <code>-cd</code> オプションを指定して実行するのと同じ。（おそらく）</p>

<h3>3. IOPS の確認</h3>

<p>前項のようにコマンドを実行した後に表示された値のうち、 <code>r/s</code> と <code>w/s</code> の値を加算したものが IOPS の値となる。</p>

<p>前項の場合、 <code>72.45</code> と <code>15.82</code> を加算した <code>88.27</code> が IOPS 値となる。</p>

<h3>4. 注意</h3>

<ul>
<li>実際には、マシン稼働中は時々刻々と値は変化しているので、何回も実行して平均を取るのがよいだろう。</li>
</ul>


<hr />

<p>当方の場合、 HDD の IOPS を確認することは、データベースの入出力に関する設定値を決定するのに必要でした。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - シャットダウン時間の短縮！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/10/mariadb-speedup-shutdown/"/>
    <updated>2015-11-10T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/10/mariadb-speedup-shutdown</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB や MySQL をシャットダウン（or 再起動）する際に時間がかかりすぎることがあります。</p>

<p>バッファの内容をディスクに書き込むのに時間がかかっているからです。</p>

<p>今回は、そのイライラを軽減するための対処についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>MariaDB 10.0.21 での作業を想定（MySQL でも同様）</li>
<li>ハード環境により成果は異なる、ということに留意。</li>
</ul>


<h3>1. シャットダウン時に行われる時間のかかる処理</h3>

<ul>
<li>InnoDB Buffer Pool 全領域のチェックポイント。</li>
<li>チェックポイントとは、ダーティページ（変更されたが、まだデータベースファイルに書き込まれていないページ）をテーブルスペースへ書き込むこと。</li>
</ul>


<h3>2. innodb_max_dirty_pages_pct について</h3>

<ul>
<li>InnoDB は、ダーティページの割合（単位：%）が <code>innodb_max_dirty_pages_pct</code> の値を超えないように、バッファープールからデータをフラッシュしようとする。</li>
<li><code>innodb_max_dirty_pages_pct</code> のデフォルト値は <code>75</code></li>
<li><code>innodb_max_dirty_pages_pct</code> の設定可能値は <code>0</code> 〜 <code>99.999</code> (MariaDB 10.0.15 以上), <code>0</code> 〜 <code>99</code> (MariaDB 10.0.15 未満).</li>
<li>書き込み回数を減らす（書き込みを遅らせる）ためにはこの値を大きくする。</li>
<li>この値を小さくし過ぎると書き込みが頻発し、<code>innodb_buffer_pool_size</code> を大きく設定していても効果が小さくなる。</li>
</ul>


<h3>3. シャットダウン時間の短縮方法</h3>

<ol>
<li>MariaDB(MySQL) サーバにログインし以下の SQLを実行する。<br/>
<code>SET GLOBAL innodb_max_dirty_pages_pct = 0;</code><br/>
（但し、環境によっては <code>0</code> を指定できないかもしれない。その場合は <code>1</code> や <code>0.001</code> 等でもよい）</li>
<li><code>Value</code> 値が十分小さくなる（<code>0</code> に近付く）まで以下の SQL を断続的に実行して待つ。<br/>
<code>SHOW GLOBAL STATUS like 'innodb_buffer_pool_pages_dirty';</code></li>
<li>サーバのシャットダウン（or 再起動）

<ul>
<li>シャットダウン（or 再起動）すると、 <code>innodb_max_dirty_pages_pct</code> の値が設定値に戻る。</li>
<li>シャットダウン（or 再起動）し忘れると <code>innodb_max_dirty_pages_pct</code> の値が <code>0</code> のままで、頻繁にダーティページのテーブルスペースへの書き込みが発生してレスポンスが悪くなるので注意。</li>
</ul>
</li>
</ol>


<h3>4. 所感</h3>

<p>シャットダウンに時間がかかりすぎて不安に感じる際には、シャットダウン前にチェックポイントを実行してダーティページの書込状況を確認できるのでよいかもしれません。</p>

<h3>5. 参考サイト</h3>

<p>シャットダウンプロセスについては以下のサイトを参照。（但し、チェックポイントやダーティページについての記載はない）</p>

<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.6/ja/server-shutdown.html" title="MySQL :: MySQL 5.6 リファレンスマニュアル :: 5.1.12 シャットダウンプロセス">MySQL :: MySQL 5.6 リファレンスマニュアル :: 5.1.12 シャットダウンプロセス</a></li>
</ul>


<hr />

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 6.7 - Postfix ウィルス対策(ClamAV + ClamSMTP)！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation/"/>
    <updated>2015-11-05T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>送信メールサーバ Postfix と Clam AntiVirus を ClamSMTP で連携してメールのウィルスチェックを行う方法についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.7(32bit) での作業を想定。</li>
<li>EPEL リポジトリ導入済み。（参考「<a href="/2013/12/13/centos-6-5-first-setting/" title="CentOS 6.5 - 初期設定！">CentOS 6.5 - 初期設定！</a>」）</li>
<li>SMTP サーバ Postfix 構築済み。</li>
<li>アンチウィルスソフト ClamAV(<code>clamd</code>) 導入済み。</li>
</ul>


<h3>1. ClamSMTP のインストール</h3>

<pre><code class="text"># yum --enablerepo=epel -y install clamsmtp
</code></pre>

<h3>2. ClamSMTP 設定ファイルの編集</h3>

<pre><code class="bash /etc/clamsmtpd.conf">Listen: 0.0.0.0:10025                           # &lt;= コメント解除

Header: X-Virus-Scanned: ClamAV using ClamSMTP  # &lt;= コメント解除

Action: drop                                    # &lt;= コメント解除
</code></pre>

<h3>3. ClamSMTP の起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/clamsmtpd start
Starting ClamSmtpd:                                        [  OK  ]

# /etc/rc.d/init.d/clamsmtp-clamd start
</code></pre>

<h3>4. ClamSMTP 自動起動の設定</h3>

<pre><code class="text"># chkconfig clamsmtpd on
# chkconfig clamsmtp-clamd on
# chkconfig --list clamsmtpd
clamsmtpd       0:off   1:off   2:on    3:on    4:on    5:on    6:off
# chkconfig --list clamsmtp-clamd
clamsmtp-clamd  0:off   1:Off   2:on    3:on    4:on    5:on    6:off
</code></pre>

<h3>5. Postfix 設定ファイルの編集</h3>

<pre><code class="bash /etc/postfix/main.cf"># 以下を最終行へ追記
content_filter = scan:127.0.0.1:10025
</code></pre>

<pre><code class="bash /etc/postfix/master.cf"># 以下を最終行へ追記
scan unix -       -       n       -       16       smtp
   -o smtp_data_done_timeout=1200
   -o smtp_send_xforward_command=yes
   -o disable_dns_lookups=yes
127.0.0.1:10026 inet n       -       n       -       16       smtpd
   -o content_filter=
   -o local_recipient_maps=
   -o relay_recipient_maps=
   -o smtpd_restriction_classes=
   -o smtpd_client_restrictions=
   -o smtpd_helo_restrictions=
   -o smtpd_sender_restrictions=
   -o smtpd_recipient_restrictions=permit_mynetworks,reject
   -o mynetworks_style=host
   -o smtpd_authorized_xforward_hosts=127.0.0.0/8
</code></pre>

<ul>
<li>上記の <code>10026</code> は &ldquo;/etc/clamsmtpd.conf&rdquo; の <code>OutAddress</code> の値に合わせる。</li>
</ul>


<h3>6. Postfix の再起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/postfix restart
Shutting down postfix:                  [  OK  ]
Starting postfix:                       [  OK  ]
</code></pre>

<h3>7. 動作確認</h3>

<p>メールを自分宛に送信してみて受信したメールのヘッダに以下のような記述があるか確認する。</p>

<pre><code class="text">X-Virus-Scanned: ClamAV using ClamSMTP
</code></pre>

<p>また、ウィルスメールを送信してみて受信しないことも確認する。（例えば、本文に以下（テストウィルス）を記載したメールを送信）</p>

<pre><code class="text">X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
</code></pre>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.server-world.info/query?os=CentOS_6&amp;p=mail&amp;f=6" title="CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World">CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World</a></li>
</ul>


<hr />

<p>送信メールサーバ Postfix と Clam AntiVirus を AMaVisd-new で連携する場合と比べてどうなのか？ということを体感してみたかった故の今回の試行でした。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - データのみを指定件数ずつ分割ダンプ出力！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split/"/>
    <updated>2015-10-26T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) の指定したデータベースを、テーブル別にデータのみを指定件数ずつ分割してダンプ出力する方法についてです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>MariaDB 10.0.21 サーバでの作業を想定。（MySQL や他のバージョンでも同様（のはず））</li>
<li>Bash スクリプトを作成して実現させる。</li>
<li>出力されたダンプファイルはまとめて圧縮保存する。</li>
<li>必要であれば、「<a href="/2014/06/15/mysql-dump-only-schema-data-stored/" title="MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！">MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！</a>」も参考にしてください。</li>
<li>以下で紹介する Bash スクリプトでは、トランザクションの単位がテーブル・ループ単位となるため、<strong>データの整合性に注意</strong>。<br/>
（<strong>ダンプ出力時やリストア時に DB への挿入・更新・削除がないことが前提</strong>）</li>
</ul>


<h3>1. Bash スクリプトの作成</h3>

<p>以下は、当方がデータのみを分割ダンプ出力する際に使用している Bash スクリプトである。（解説はスクリプト内のコメントにて。 <code>(*)</code> はさらなる説明を後述）</p>

<pre><code class="bash db_dump_only_data_by_split.sh">#!/bin/bash

# 定数定義
DB=db_name                      # データベース・スキーマ名
USER=user_name                  # ダンプ出力するユーザ名
PW=user_password                #       〃      ユーザ名のパスワード
CMD=/usr/bin/mysqldump          # mysqldump コマンドのフルパス
WK_DIR=/path/to/backup_mysql    # 作業ディレクトリ
DMP_DIR=$WK_DIR/tabledatas_$DB  # ダンプファイル格納ディレクトリ
OPTS="-t -Q -F --skip-lock-tables --skip-triggers --skip-dump-date --single-transaction"
                                # mysqldump オプション(*)
DCNT=100000                     # 分割するレコード件数

# ダンプファイルクリア
rm -f $DMP_DIR/*

# DB 内に存在するテーブル毎にループ処理
for tbl in `mysql -u $USER -p$PW -N -s -e "show tables in $DB;"`; do
  # テーブル内に存在するレコード件数(*)
  rows=`mysql -u $USER -p$PW $DB -N -B -e "SELECT COUNT(*) FROM $tbl;"`
  echo "* $tbl [$rows records]"

  # レコード件数から分割数を算出してループ処理
  for ((i = 0; i &lt;= $(($rows / $DCNT)); i++))
  do
    # 出力ダンプファイル名
    fname=$(printf ${tbl}_%02d $i)
    # オフセット算出
    offset=$((i * $DCNT))
    echo "  $fname [OFFSET: $offset]"
    # ダンプ出力(*)
    $CMD -u $USER -p$PW $DB $tbl $OPTS -w "true LIMIT $offset, $DCNT"&gt; $DMP_DIR/$fname.sql
  done;
done;

# タイムスタンプ付ファイル名で圧縮保存
cd $WK_DIR
dt=`date '+%Y%m%d_%H%M%S'`
tar zcvf ${DB}_tabledata_$dt.tar.gz tabledatas_$DB
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/d9cae95bf4d30da5545b" title="Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.">Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.</a></li>
</ul>


<p>mysqldump オプション（上記の<code>OPTS</code>）について。（mysqldump のデフォルトで有効のオプション <code>--opt</code> とは別のもの）</p>

<ul>
<li><code>-t</code>(or <code>--no-create-info</code>) &hellip; テーブル作成（CREATE TABLE）文を出力しないオプション。</li>
<li><code>-Q</code>(or <code>--quote-names</code>) &hellip; データベース名、テーブル名、カラム名を <code>`</code> で囲むオプション（デフォルトで有効）。</li>
<li><code>-F</code>(or <code>--flush-logs</code>) &hellip; ダンプ開始前にログファイルをフラッシュするオプション。</li>
<li><code>--skip-lock-tables</code> &hellip; デフォルトで有効になる全テーブルをロックするオプション <code>--lock-tables</code> を無効にするオプション。</li>
<li><code>--skip-triggers</code> &hellip; trigger のダンプ出力を無効にするオプション。</li>
<li><code>--skip-dump-date</code> &hellip; ダンプ日時の出力を無効にするオプション。</li>
<li><code>--single-transaction</code> &hellip; データの整合性を保つためにダンプ処理をトランザクションで囲むオプション。</li>
<li>ちなみに、主キーでソートせずに LIMIT(OFFSET) 句を使用するとフルスキャンになってしまうからと、 <code>--order-by-primary</code> という主キーでソートするオプションを使用すると、 Syntax error が発生しまう。従って、今回は使用していない。<br/>
主キーでソートしたければ、 <code>-w</code> オプションの <code>LIMIT</code> 句の前に <code>ORDER BY primary_key_col</code> のように追加する。（但し、今回紹介のケースでは DB 内全テーブルの主キーが同じカラムである必要がある）</li>
</ul>


<p>レコード件数取得について。</p>

<ul>
<li>上記では <code>SELECT COUNT(*) ...</code> としているが、データベース内の全テーブルに同じカラム名で主キーが設定してあるのなら <code>SELECT COUNT(col_name) ...</code> とした方がよい。</li>
</ul>


<p><code>OPTS</code> 以外に追加している <code>-w</code>(or <code>--where</code>) オプションについて。（<strong>今回のポイント</strong>）</p>

<ul>
<li>本来 <code>-w</code> は抽出条件を指定するオプションだが、 WHERE 条件は <code>true</code>（もしくは <code>1</code>） でスルーして <code>LIMIT</code> 句を指定している。<br/>
（mysqldump に LIMIT(OFFSET) 句を指定するオプションが存在しないため）</li>
<li><code>-w "true LIMIT $offset, $DCNT"</code> は <code>-w "true LIMIT $DCNT OFFSET $offset"</code> としてもよい。</li>
<li>主キーやユニークインデックスが歯抜けでなく件数が正確に取得できるのであれば、 <code>-w</code> オプションで LIMIT 句や OFFSET 句を指定せずに普通に条件指定するようにしてもよいだろう。</li>
</ul>


<h3>2. Bash スクリプトの実行</h3>

<p>作業用ディレクトリやダンプファイル格納用サブディレクトリが存在することを確認し、実行権限を付与後に実行する。</p>

<pre><code class="text">$ chmod +x db_dump_only_data_by_split.sh
$ ./db_dump_only_data_by_split.sh
</code></pre>

<p>作業ディレクトリ内のダンプファイル格納用サブディレクトリにダンプファイルが出力され、作業ディレクトリ内にタイムスタンプ付圧縮ファイルが作成されるのを確認する。</p>

<p>また、 LIMIT 句を使用しているのでダンプ出力完了まで時間がかかることを覚悟すること。</p>

<h3>3. その他</h3>

<ul>
<li>データ量が多すぎるとダンプ出力に時間がかかる、ということに留意する。<br/>
<code>-w</code> オプションで LIMIT 句を使用するからと、フルスキャンを避けるために <code>--order-by-primary</code> オプションを使用したり、もしくは <code>-w</code> オプションで <code>ORDER BY</code> 句を指定しても、ダンプ出力が徐々に遅くなる。<br/>
<code>mysqldump</code> の <code>-w</code>(or <code>--where</code>) での LIMIT(OFFSET) 句指定はフルスキャンになってしまうのだろうか？（<code>mysqldump</code> を EXPLAIN で確認できればいいのですが。。。）</li>
<li>データ量が多すぎるとダンプ出力に時間がかかるため、結局当方は、データ量が多すぎる場合は、エクスポートは <code>SELECT INTO ... OUTFILE</code> で CSV 出力、インポートは <code>LOAD DATA INFILE</code> で CSV 取り込み、とすることにした。以下の過去記事を参照。

<ul>
<li><a href="/2011/08/31/31002049/" title="MySQL - SELECT結果をCSV出力！">MySQL - SELECT結果をCSV出力！</a></li>
<li><a href="/2013/06/08/mysql-import-from-csv/" title="MySQL - CSV データインポート！">MySQL - CSV データインポート！</a></li>
</ul>
</li>
</ul>


<h3>4. 参考サイト</h3>

<p>mysqldump の各種オプションや LIMIT 句の指定方法については以下のサイトを参照。</p>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" title="MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program">MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program</a></li>
</ul>


<hr />

<p>結局、当方は今回紹介した方法を積極的には使用していませんが、こういうやり方もあるということを覚えておくと何かの際に役立つかもしれません。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - スワップ領域の作成！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/20/linux-create-swap-area/"/>
    <updated>2015-10-20T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/20/linux-create-swap-area</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>スワップ領域の容量が不足した際に追加で作成する方法についてです。</p>

<p>本来なら物理メモリを増設すべきでしょうが、それまでの緊急的な措置としてスワップファイルを作成してそれをスワップ領域に割り当てるのです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.6(32bit) での作業を想定。（他のディストリビューションでも同じ）</li>
</ul>


<h3>1. スワップファイルの作成</h3>

<p>以下は、ブロックサイズ 1KB で 2GB(1024 x 1024 x 2ブロック) のスワップ領域用のファイルを作成する例。</p>

<pre><code class="text"># dd if=/dev/zero of=/var/tmp/swap bs=1024 count=2097152
2097152+0 records in
2097152+0 records out
2147483648 bytes (2.1 GB) copied, 74.8475 s, 28.7 MB/s
</code></pre>

<h3>2. スワップ領域の作成</h3>

<p>先ほど作成したスワップファイルをスワップ領域に割り当てる。</p>

<pre><code class="text"># mkswap /var/tmp/swap
mkswap: /var/tmp/swap: warning: don't erase bootbits sectors
        on whole disk. Use -f to force.
スワップ空間バージョン1を設定します、サイズ = 2097148 KiB
ラベルはありません, UUID=1a802279-4f23-4466-8579-fa38a2cc4d5a
</code></pre>

<ul>
<li>スワップ領域を作成する前にデバイスの不良ブロックのチェックを行いたい場合は、 <code>-c</code> オプションを使用する。<br/>
（不良ブロックを検出した場合は、その件数が出力される）</li>
<li>スワップファイルにラベルを指定する（ラベル指定でスワップ領域の有効化したい）場合は、 <code>-L</code> オプションで指定する。</li>
</ul>


<h3>3. スワップ領域の有効化</h3>

<p>先ほど作成したスワップ領域を有効化する。</p>

<pre><code class="text"># swapon /var/tmp/swap
</code></pre>

<ul>
<li>当然ながら、スワップファイルではなくパーティションを指定することも可能。</li>
<li>スワップファイル名でなくラベルで指定することも可能。</li>
<li>優先度を指定したければ、 <code>-p priority</code> で指定する。 <code>priority</code> は 0 〜 32767 の数値で、大きいほど優先度が高い。</li>
<li>同じ優先度のスワップ領域が複数ある場合、ページがラウンド・ロビン方式で配分される。</li>
</ul>


<h3>4. スワップ領域の確認</h3>

<p>スワップ領域の一覧を確認するには以下のようにする。（以下は一例）</p>

<pre><code class="text"># swapon -s
Filename                                Type            Size    Used    Priority
/dev/sda2                               partition       2097148 766580  -1
/var/tmp/swap                           file            2097148 0       -2
</code></pre>

<ul>
<li>優先度を指定しない場合、自動で既存スワップ領域で最低の優先度に続く優先度になるのではなかろうか。</li>
</ul>


<h3>5. スワップ領域の削除</h3>

<p>スワップが不要になった場合は以下のようにして削除する。</p>

<pre><code class="text"># swapoff /var/tmp/swap
</code></pre>

<ul>
<li>当然ながら、スワップファイルではなくパーティションを指定することも可能。</li>
<li>スワップファイル名でなくラベルで指定することも可能。</li>
</ul>


<h3>6. スワップファイルの削除</h3>

<p>完全にスワップ領域が不要なら、スワップファイルも削除する。（単純なファイル削除）</p>

<pre><code class="text"># rm -f /var/tmp/swap
</code></pre>

<h3>7. 自動マウント</h3>

<p>マシン起動時に自動でスワップ領域を有効化したい場合は、 &ldquo;/etc/fstab&rdquo; に以下のように追記する。</p>

<pre><code class="text /etc/fstab">/var/tmp/swap         swap    swap    sw    0 0
</code></pre>

<ul>
<li>1列目 &hellip; デバイス名・スワップファイル名</li>
<li>2列目 &hellip; マウントポイント（スワップ領域にはマウントポイントがないので <code>none</code> でもよい）</li>
<li>3列目 &hellip; ファイルシステム</li>
<li>4列目 &hellip; マウント時のオプション（<code>defaults</code> でもよい。優先度を指定するなら <code>sw,pri=X</code>（<code>X</code> は <code>0</code> 〜 <code>32767</code> の数値））</li>
<li>5列目 &hellip; ファイルシステムを dump する必要があるか否かの指定（<code>0</code> は dump の必要なし）</li>
<li>6列目 &hellip; システム起動時に fsck チェックを行うか否かの指定（<code>0</code> は fsck チェックを行わない）</li>
</ul>


<hr />

<p>これで取り急ぎのスワップ領域拡大ができますが、この間に物理メモリ増設について検討しましょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
