<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: サーバ構築 | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/サーバ構築/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-12-03T00:07:19+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - ロールフォワード（ポイント・イン・タイム）リカバリ！]]></title>
    <link href="http://komasaru.github.io/blog/2015/12/03/mariadb-rollforward-recovery/"/>
    <updated>2015-12-03T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/12/03/mariadb-rollforward-recovery</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) で障害発生時に、定期的に取得していたダンプファイルでリストアするだけでは、当然タイミングによっては古い状態になってしまいます。</p>

<p>以下は、定期的に取得していたダンプファイルとそれより後のログファイルで障害発生直前の状態までリカバリする方法についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>MySQL 5.6 系、 MariaDB 10.0 系での作業を想定。<br/>
（他のバージョンでもそれほど古くなければ同様）</li>
<li>バイナリロギングが有効になっている。
（設定ファイル &ldquo;my.cnf&rdquo; で <code>log-bin=...</code> の行がコメント化されていない、もしくはサーバ起動時に <code>--log-bin</code> オプションを使用している）</li>
</ul>


<h3>1. はじめに</h3>

<ul>
<li>ロールフォワードリカバリとは、簡単には、

<ul>
<li>バックアップファイルとジャーナルファイルを用いて、障害発生以前の状態に復元すること。（某国家試験で出題される基本的なこと）<br/>
今回の MariaDB(MySQL) での作業では、ダンプファイルとバイナリログファイルがそれにあたる。</li>
</ul>
</li>
<li>ポイント・イン・タイムリカバリ(Point-In-Time Recovery, PITR)とは、簡単には、

<ul>
<li>指定した時間の状態に戻すこと。</li>
<li>障害が発生する直前の状態まで戻すこと。</li>
<li>Oracle の「完全・不完全リカバリ」にあたるもの。</li>
</ul>
</li>
</ul>


<h3>2. 基本的な作業の流れ</h3>

<ol>
<li>ダンプ出力（<code>mysqldump</code> による定期バックアップ）</li>
<li>通常運用</li>
<li>障害発生</li>
<li>ダンプファイルのリストア</li>
<li>バイナリログの適用（ダンプリストア後〜障害発生直前）</li>
<li>復元確認</li>
</ol>


<h3>3. 作業例</h3>

<p>当然ながら、当作業中は整合性を保つためにデータベースサーバへのアクセスが発生しないようにしておくこと。（アプリの停止、Web サーバの停止等）</p>

<h4>3-1. ダンプ出力（<code>mysqldump</code> による定期バックアップ）</h4>

<p>以下のようなコマンドを cron 実行するなどして、定期的にバックアップを取る。</p>

<pre><code class="text">mysqldump -u root -proot_password --single-transaction --master-data --flush-logs db_name &gt; db_name.sql
</code></pre>

<ul>
<li><code>--single-transaction</code> は、データの整合性を保つためにダンプをトランザクションで囲むオプション。</li>
<li><code>--master-data</code> は、<code>CHANGE MASTER TO</code> 句（ポイント・イン・タイムリカバリを開始するバイナリファイル・ポイントの情報）を出力するオプション。</li>
<li><code>--flush-logs</code> は、ダンプ出力後にバイナリログを新しく作成（フラッシュ）するオプション。 <code>-F</code> も同じ。</li>
<li><code>--flush-logs</code> オプションを使用した場合は、ポイント・イン・タイムリカバリを開始するポイントは新しいバイナリファイルの先頭ポイントなので、 <code>--master-data</code> オプションを使用する不要はないかもしれない。</li>
<li><code>--master-logs</code> オプションを使用した場合は、ポイント・イン・タイムリカバリを開始するポイントが明確に分かるので、敢えて <code>--flush-logs</code> オプションを使用する必要はないかもしれない。</li>
<li>場合によっては、 <code>--quote-names</code>（or <code>-Q</code>）, <code>--skip-lock-tables</code> 等のオプションも使用。</li>
<li>場合によっては、 <code>--all-databases</code>（or <code>-A</code>）オプションで全 DB をダンプ出力してもよいだろう。</li>
</ul>


<h4>3-2. 通常運用</h4>

<p>当然ながら、ダンプ出力後も通常どおり運用されている。(INSERT, UPDATE, DELETE etc.)</p>

<h4>3-3. 障害発生</h4>

<p>通常運用時に何らかの障害が発生する。（今回は、人為的なミスで１テーブルを <code>DROP</code> してしまったことを想定）</p>

<h4>3-4. ダンプファイルのリストア</h4>

<p>障害発生時には、まず定期的に取っていたダンプファイルを使用してリストアする。</p>

<pre><code class="text"># mysql -u root -p db_name &lt; db_name.sql
</code></pre>

<h4>3-5. バイナリログの適用（ダンプリストア後〜障害発生直前）</h4>

<p>まず、ダンプファイルからポイント・イン・タイムリカバリを開始するバイナリログファイル・ポイントを確認する。</p>

<pre><code class="text"># cat /path/to/db_name.sql | CHANGE
CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.004962', MASTER_LOG_POS=365;
</code></pre>

<p>この例では、バイナリログファイル &ldquo;mysql-bin.004962&rdquo; の ポイント &ldquo;365&rdquo; より前まではダンプファイルでリストアできているということ。</p>

<p>次に、障害が発生したポイントを最新のバイナリログから検索する。</p>

<p>以下は、誤ってテーブル test_table を DROP してしまった場合にそのポイントを検索する例。<br/>
該当行より３行くらい前にポイントが記載されているので、 <code>grep</code> コマンドに <code>-B 3</code> オプションを使用している。<br/>
また、 &ldquo;my.cnf&rdquo; の <code>[client]</code> に <code>default-character-set</code> が存在すると <code>unknown variable</code> エラーが発生するため、<code>--no-defaults</code> オプションを使用している。</p>

<pre><code class="text"># mysqlbinlog --nodefaults --database=db_name /path/to/mysql-bin.004962 | grep -B 3 DROP
# at 10923096
#151029 11:15:17 server id 1  end_log_pos 10923228      Query   thread_id=1124470       exec_time=0     error_code=0
SET TIMESTAMP=1446084917/*!*/;
DROP TABLE test_table
</code></pre>

<p>この場合、ポイントは <code>10923096</code> であるということ。</p>

<p>いよいよ、バイナリログを適用する。<br/>
以下は、バイナリログファイル &ldquo;mysql-bin.004962&rdquo; の先頭ポイントからポイント &ldquo;10923096&rdquo; の <code>--database</code> オプションで指定したデータベースのバイナリログを適用する例。
（<code>--disable-log-bin</code>（or <code>-D</code>） オプションはバイナリログの出力を無効にするオプション。バイナリログ適用時にまでバイナリログを出力する必要はないので）</p>

<pre><code class="text"># mysqlbinlog --database=db_name --disable-log-bin --stop-position=10923096 /path/to/mysql-bin.004962 | mysql -u root -p
</code></pre>

<p>ちなみに、ダンプ出力後のバイナリログファイルが複数ある場合は以下のように並べて記載する。<br/>
この場合、<code>--stop-position</code> オプションは最後のバイナリログファイルに対してのみ有効。</p>

<pre><code class="text"># mysqlbinlog --database=db_name --disable-log-bin --stop-position=10923096 /path/to/mysql-bin.004960 /path/to/mysql-bin.004962 | mysql -u root -proot_password
</code></pre>

<p>仮にダンプ出力時に <code>--flush-logs</code> オプションを指定していなかった場合は開始ポイントが明確でないため、明示的に <code>--start-position</code> オプションで指定する必要がある。（バイナリログファイルが複数ある場合は <code>--start-position</code> は最初のバイナリログファイルに対してのみ有効）</p>

<h4>3-6. 復元確認</h4>

<p>後は、正常に復元されたか確認するだけ。</p>

<h3>4. その他＆注意事項</h3>

<ul>
<li>今回はポジションを意識したリカバリを行なったが、状況によっては日付を意識したリカバリも可能。（<code>--start-datatime</code>, <code>--stop-datetim</code> オプションを使用）</li>
<li><code>mysqlbinlog</code> コマンドでバイナリログファイルを複数指定する際は、一度に全て指定すること。（１ファイルずつ複数に分けて実行しない）</li>
<li>バイナリログファイルが複数存在する場合は、１つにマージしてから <code>mysqlbinlog</code> を実行してもよい。</li>
<li><code>mysqlbinlog ... binlog | mysql -u root -p</code> のようにパイプを使用せず、 <code>mysqlbinlog ... binlog &gt; statements.sql</code> 実行後に <code>mysql -u root -p &lt; statements.sql</code> を実行してもよい。</li>
</ul>


<h3>5. 参考サイト</h3>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/ja/point-in-time-recovery.html" title="MySQL :: MySQL 5.6 リファレンスマニュアル :: 7.5 バイナリログを使用したポイントインタイム (増分) リカバリ">MySQL :: MySQL 5.6 リファレンスマニュアル :: 7.5 バイナリログを使用したポイントインタイム (増分) リカバリ</a></li>
</ul>


<hr />

<p>有事の際にしか行わない作業なので、記録として残しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - Disk の IOPS の確認！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/15/linux-check-disk-iops/"/>
    <updated>2015-11-15T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/15/linux-check-disk-iops</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>今回は、Linux OS でハードディスクが単位時間当たりどれくらい入出力要求をこなしているのか？を確認する方法についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CPU と入出力装置の負荷を確認するための <code>iostat</code> コマンドを使用する。</li>
<li>Linux Mint や Debian 等はデフォルトではインストールされていないかもしれない。<br/>
その場合は、 <code>apt-get install sysstat</code> 等でインストールする。</li>
</ul>


<h3>1. IOPS について</h3>

<p>まず &ldquo;IOPS&rdquo; とは、記憶装置がある条件下で1秒間で読み込み・書き込みができる回数のことで、 &ldquo;Input/Output Per Second&rdquo; の略である。</p>

<h3>2. コマンドの実行</h3>

<p>以下のようにコマンドを実行する。</p>

<pre><code class="text"># iostat -dx
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda              51.59    64.81   72.45   15.82    17.47    44.00     0.70     0.31    3.47   0.89   7.82
</code></pre>

<ul>
<li><code>-d</code> はデバイスの利用統計のみを表示するオプション。</li>
<li><code>-x</code> は指定したデバイスの統計を追加表示するオプション。<br/>
（デバイス名を指定しなかった場合は、 &ldquo;/proc/partitions&rdquo; に登録されている全てのデバイスについて表示される）</li>
<li><code>iostat -dx 3 10</code> のように実行すると、3秒間隔で10回表示する。</li>
<li>出力項目について

<ul>
<li><code>rrqm/s</code> &hellip; 結合したデバイスの入力要求の数</li>
<li><code>wrqm/s</code> &hellip; 結合したデバイスの出力要求の数</li>
<li><code>r/s</code> &hellip; 1秒間にデバイスに出力された入力要求の数</li>
<li><code>w/s</code> &hellip; 1秒間にデバイスに出力された出力要求の数</li>
<li><code>rsec/s</code> &hellip; 1秒間にデバイスから読み込んだセクタ数</li>
<li><code>wsec/s</code> &hellip; 1秒間にデバイスへ書き込んだセクタ数</li>
<li><code>avgrq-sz</code> &hellip; デバイスに出された入出力要求の平均サイズ</li>
<li><code>avgqu-sz</code> &hellip; デバイスに出された入出力要求のキューの長さの平均</li>
<li><code>await</code> &hellip; デバイスに出された入出力要求が受け取られるまでの平均時間</li>
<li><code>svctm</code> &hellip; デバイスに出された入出力要求の平均処理時間</li>
<li><code>%util</code> &hellip; デバイスの入出力要求を出す間に使用したCPUの平均時間</li>
</ul>
</li>
</ul>


<p>ちなみに、 <code>-x</code> オプションを使用しない場合は以下のように出力される。</p>

<pre><code class="text"># iostat -d
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda              88.28        17.98        44.05  249632216  611679582
</code></pre>

<ul>
<li>出力項目について

<ul>
<li><code>tps</code> &hellip; デバイスへの入出力要求の数</li>
<li><code>Blk_read/s</code> &hellip; デバイスから読み込んだブロック数の平均</li>
<li><code>Blk_wrtn/s</code> &hellip; デバイスへ書き込んだブロック数の平均</li>
<li><code>Blk_read</code> &hellip; 読み込んだブロック数</li>
<li><code>Blk_wrtn</code> &hellip; 書き込んだブロック数</li>
</ul>
</li>
</ul>


<p>更には、 <code>-c</code> オプションで CPU の利用統計が確認できる。</p>

<pre><code class="text"># iostat -c
Linux 2.6.32-504.16.2.el6.i686 (hoge.mk-mode.com)     2015年10月06日 _i686_  (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          11.57    2.39    2.35   31.88    0.00   51.81
</code></pre>

<ul>
<li>出力項目について

<ul>
<li><code>%user</code> &hellip; ユーザレベルでのCPU使用率(%)</li>
<li><code>%nice</code> &hellip; ユーザレベルで、優先的にCPUを使用したときのCPU使用率(%)</li>
<li><code>%system</code> &hellip; システムレベルでのCPU使用率(%)</li>
<li><code>%iowait</code> &hellip; CPU総時間当たりのI/O待ち時間率(%)</li>
<li><code>%steal</code> &hellip; ゲストOSがリソース要求を行ったにもかかわらずCPUリソースを割り当ててもらえなかった時間の割合(%)</li>
<li><code>%idle</code> &hellip; CPUのアイドル率(%)</li>
</ul>
</li>
</ul>


<p>そして、<code>iostat</code> をオプションを全く指定しないで実行するのは <code>-cd</code> オプションを指定して実行するのと同じ。（おそらく）</p>

<h3>3. IOPS の確認</h3>

<p>前項のようにコマンドを実行した後に表示された値のうち、 <code>r/s</code> と <code>w/s</code> の値を加算したものが IOPS の値となる。</p>

<p>前項の場合、 <code>72.45</code> と <code>15.82</code> を加算した <code>88.27</code> が IOPS 値となる。</p>

<h3>4. 注意</h3>

<ul>
<li>実際には、マシン稼働中は時々刻々と値は変化しているので、何回も実行して平均を取るのがよいだろう。</li>
</ul>


<hr />

<p>当方の場合、 HDD の IOPS を確認することは、データベースの入出力に関する設定値を決定するのに必要でした。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - シャットダウン時間の短縮！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/10/mariadb-speedup-shutdown/"/>
    <updated>2015-11-10T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/10/mariadb-speedup-shutdown</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB や MySQL をシャットダウン（or 再起動）する際に時間がかかりすぎることがあります。</p>

<p>バッファの内容をディスクに書き込むのに時間がかかっているからです。</p>

<p>今回は、そのイライラを軽減するための対処についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>MariaDB 10.0.21 での作業を想定（MySQL でも同様）</li>
<li>ハード環境により成果は異なる、ということに留意。</li>
</ul>


<h3>1. シャットダウン時に行われる時間のかかる処理</h3>

<ul>
<li>InnoDB Buffer Pool 全領域のチェックポイント。</li>
<li>チェックポイントとは、ダーティページ（変更されたが、まだデータベースファイルに書き込まれていないページ）をテーブルスペースへ書き込むこと。</li>
</ul>


<h3>2. innodb_max_dirty_pages_pct について</h3>

<ul>
<li>InnoDB は、ダーティページの割合（単位：%）が <code>innodb_max_dirty_pages_pct</code> の値を超えないように、バッファープールからデータをフラッシュしようとする。</li>
<li><code>innodb_max_dirty_pages_pct</code> のデフォルト値は <code>75</code></li>
<li><code>innodb_max_dirty_pages_pct</code> の設定可能値は <code>0</code> 〜 <code>99.999</code> (MariaDB 10.0.15 以上), <code>0</code> 〜 <code>99</code> (MariaDB 10.0.15 未満).</li>
<li>書き込み回数を減らす（書き込みを遅らせる）ためにはこの値を大きくする。</li>
<li>この値を小さくし過ぎると書き込みが頻発し、<code>innodb_buffer_pool_size</code> を大きく設定していても効果が小さくなる。</li>
</ul>


<h3>3. シャットダウン時間の短縮方法</h3>

<ol>
<li>MariaDB(MySQL) サーバにログインし以下の SQLを実行する。<br/>
<code>SET GLOBAL innodb_max_dirty_pages_pct = 0;</code><br/>
（但し、環境によっては <code>0</code> を指定できないかもしれない。その場合は <code>1</code> や <code>0.001</code> 等でもよい）</li>
<li><code>Value</code> 値が十分小さくなる（<code>0</code> に近付く）まで以下の SQL を断続的に実行して待つ。<br/>
<code>SHOW GLOBAL STATUS like 'innodb_buffer_pool_pages_dirty';</code></li>
<li>サーバのシャットダウン（or 再起動）

<ul>
<li>シャットダウン（or 再起動）すると、 <code>innodb_max_dirty_pages_pct</code> の値が設定値に戻る。</li>
<li>シャットダウン（or 再起動）し忘れると <code>innodb_max_dirty_pages_pct</code> の値が <code>0</code> のままで、頻繁にダーティページのテーブルスペースへの書き込みが発生してレスポンスが悪くなるので注意。</li>
</ul>
</li>
</ol>


<h3>4. 所感</h3>

<p>シャットダウンに時間がかかりすぎて不安に感じる際には、シャットダウン前にチェックポイントを実行してダーティページの書込状況を確認できるのでよいかもしれません。</p>

<h3>5. 参考サイト</h3>

<p>シャットダウンプロセスについては以下のサイトを参照。（但し、チェックポイントやダーティページについての記載はない）</p>

<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.6/ja/server-shutdown.html" title="MySQL :: MySQL 5.6 リファレンスマニュアル :: 5.1.12 シャットダウンプロセス">MySQL :: MySQL 5.6 リファレンスマニュアル :: 5.1.12 シャットダウンプロセス</a></li>
</ul>


<hr />

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 6.7 - Postfix ウィルス対策(ClamAV + ClamSMTP)！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation/"/>
    <updated>2015-11-05T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>送信メールサーバ Postfix と Clam AntiVirus を ClamSMTP で連携してメールのウィルスチェックを行う方法についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.7(32bit) での作業を想定。</li>
<li>EPEL リポジトリ導入済み。（参考「<a href="/2013/12/13/centos-6-5-first-setting/" title="CentOS 6.5 - 初期設定！">CentOS 6.5 - 初期設定！</a>」）</li>
<li>SMTP サーバ Postfix 構築済み。</li>
<li>アンチウィルスソフト ClamAV(<code>clamd</code>) 導入済み。</li>
</ul>


<h3>1. ClamSMTP のインストール</h3>

<pre><code class="text"># yum --enablerepo=epel -y install clamsmtp
</code></pre>

<h3>2. ClamSMTP 設定ファイルの編集</h3>

<pre><code class="bash /etc/clamsmtpd.conf">Listen: 0.0.0.0:10025                           # &lt;= コメント解除

Header: X-Virus-Scanned: ClamAV using ClamSMTP  # &lt;= コメント解除

Action: drop                                    # &lt;= コメント解除
</code></pre>

<h3>3. ClamSMTP の起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/clamsmtpd start
Starting ClamSmtpd:                                        [  OK  ]

# /etc/rc.d/init.d/clamsmtp-clamd start
</code></pre>

<h3>4. ClamSMTP 自動起動の設定</h3>

<pre><code class="text"># chkconfig clamsmtpd on
# chkconfig clamsmtp-clamd on
# chkconfig --list clamsmtpd
clamsmtpd       0:off   1:off   2:on    3:on    4:on    5:on    6:off
# chkconfig --list clamsmtp-clamd
clamsmtp-clamd  0:off   1:Off   2:on    3:on    4:on    5:on    6:off
</code></pre>

<h3>5. Postfix 設定ファイルの編集</h3>

<pre><code class="bash /etc/postfix/main.cf"># 以下を最終行へ追記
content_filter = scan:127.0.0.1:10025
</code></pre>

<pre><code class="bash /etc/postfix/master.cf"># 以下を最終行へ追記
scan unix -       -       n       -       16       smtp
   -o smtp_data_done_timeout=1200
   -o smtp_send_xforward_command=yes
   -o disable_dns_lookups=yes
127.0.0.1:10026 inet n       -       n       -       16       smtpd
   -o content_filter=
   -o local_recipient_maps=
   -o relay_recipient_maps=
   -o smtpd_restriction_classes=
   -o smtpd_client_restrictions=
   -o smtpd_helo_restrictions=
   -o smtpd_sender_restrictions=
   -o smtpd_recipient_restrictions=permit_mynetworks,reject
   -o mynetworks_style=host
   -o smtpd_authorized_xforward_hosts=127.0.0.0/8
</code></pre>

<ul>
<li>上記の <code>10026</code> は &ldquo;/etc/clamsmtpd.conf&rdquo; の <code>OutAddress</code> の値に合わせる。</li>
</ul>


<h3>6. Postfix の再起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/postfix restart
Shutting down postfix:                  [  OK  ]
Starting postfix:                       [  OK  ]
</code></pre>

<h3>7. 動作確認</h3>

<p>メールを自分宛に送信してみて受信したメールのヘッダに以下のような記述があるか確認する。</p>

<pre><code class="text">X-Virus-Scanned: ClamAV using ClamSMTP
</code></pre>

<p>また、ウィルスメールを送信してみて受信しないことも確認する。（例えば、本文に以下（テストウィルス）を記載したメールを送信）</p>

<pre><code class="text">X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
</code></pre>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.server-world.info/query?os=CentOS_6&amp;p=mail&amp;f=6" title="CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World">CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World</a></li>
</ul>


<hr />

<p>送信メールサーバ Postfix と Clam AntiVirus を AMaVisd-new で連携する場合と比べてどうなのか？ということを体感してみたかった故の今回の試行でした。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - データのみを指定件数ずつ分割ダンプ出力！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split/"/>
    <updated>2015-10-26T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) の指定したデータベースを、テーブル別にデータのみを指定件数ずつ分割してダンプ出力する方法についてです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>MariaDB 10.0.21 サーバでの作業を想定。（MySQL や他のバージョンでも同様（のはず））</li>
<li>Bash スクリプトを作成して実現させる。</li>
<li>出力されたダンプファイルはまとめて圧縮保存する。</li>
<li>必要であれば、「<a href="/2014/06/15/mysql-dump-only-schema-data-stored/" title="MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！">MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！</a>」も参考にしてください。</li>
<li>以下で紹介する Bash スクリプトでは、トランザクションの単位がテーブル・ループ単位となるため、<strong>データの整合性に注意</strong>。<br/>
（<strong>ダンプ出力時やリストア時に DB への挿入・更新・削除がないことが前提</strong>）</li>
</ul>


<h3>1. Bash スクリプトの作成</h3>

<p>以下は、当方がデータのみを分割ダンプ出力する際に使用している Bash スクリプトである。（解説はスクリプト内のコメントにて。 <code>(*)</code> はさらなる説明を後述）</p>

<pre><code class="bash db_dump_only_data_by_split.sh">#!/bin/bash

# 定数定義
DB=db_name                      # データベース・スキーマ名
USER=user_name                  # ダンプ出力するユーザ名
PW=user_password                #       〃      ユーザ名のパスワード
CMD=/usr/bin/mysqldump          # mysqldump コマンドのフルパス
WK_DIR=/path/to/backup_mysql    # 作業ディレクトリ
DMP_DIR=$WK_DIR/tabledatas_$DB  # ダンプファイル格納ディレクトリ
OPTS="-t -Q -F --skip-lock-tables --skip-triggers --skip-dump-date --single-transaction"
                                # mysqldump オプション(*)
DCNT=100000                     # 分割するレコード件数

# ダンプファイルクリア
rm -f $DMP_DIR/*

# DB 内に存在するテーブル毎にループ処理
for tbl in `mysql -u $USER -p$PW -N -s -e "show tables in $DB;"`; do
  # テーブル内に存在するレコード件数(*)
  rows=`mysql -u $USER -p$PW $DB -N -B -e "SELECT COUNT(*) FROM $tbl;"`
  echo "* $tbl [$rows records]"

  # レコード件数から分割数を算出してループ処理
  for ((i = 0; i &lt;= $(($rows / $DCNT)); i++))
  do
    # 出力ダンプファイル名
    fname=$(printf ${tbl}_%02d $i)
    # オフセット算出
    offset=$((i * $DCNT))
    echo "  $fname [OFFSET: $offset]"
    # ダンプ出力(*)
    $CMD -u $USER -p$PW $DB $tbl $OPTS -w "true LIMIT $offset, $DCNT"&gt; $DMP_DIR/$fname.sql
  done;
done;

# タイムスタンプ付ファイル名で圧縮保存
cd $WK_DIR
dt=`date '+%Y%m%d_%H%M%S'`
tar zcvf ${DB}_tabledata_$dt.tar.gz tabledatas_$DB
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/d9cae95bf4d30da5545b" title="Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.">Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.</a></li>
</ul>


<p>mysqldump オプション（上記の<code>OPTS</code>）について。（mysqldump のデフォルトで有効のオプション <code>--opt</code> とは別のもの）</p>

<ul>
<li><code>-t</code>(or <code>--no-create-info</code>) &hellip; テーブル作成（CREATE TABLE）文を出力しないオプション。</li>
<li><code>-Q</code>(or <code>--quote-names</code>) &hellip; データベース名、テーブル名、カラム名を <code>`</code> で囲むオプション（デフォルトで有効）。</li>
<li><code>-F</code>(or <code>--flush-logs</code>) &hellip; ダンプ開始前にログファイルをフラッシュするオプション。</li>
<li><code>--skip-lock-tables</code> &hellip; デフォルトで有効になる全テーブルをロックするオプション <code>--lock-tables</code> を無効にするオプション。</li>
<li><code>--skip-triggers</code> &hellip; trigger のダンプ出力を無効にするオプション。</li>
<li><code>--skip-dump-date</code> &hellip; ダンプ日時の出力を無効にするオプション。</li>
<li><code>--single-transaction</code> &hellip; データの整合性を保つためにダンプ処理をトランザクションで囲むオプション。</li>
<li>ちなみに、主キーでソートせずに LIMIT(OFFSET) 句を使用するとフルスキャンになってしまうからと、 <code>--order-by-primary</code> という主キーでソートするオプションを使用すると、 Syntax error が発生しまう。従って、今回は使用していない。<br/>
主キーでソートしたければ、 <code>-w</code> オプションの <code>LIMIT</code> 句の前に <code>ORDER BY primary_key_col</code> のように追加する。（但し、今回紹介のケースでは DB 内全テーブルの主キーが同じカラムである必要がある）</li>
</ul>


<p>レコード件数取得について。</p>

<ul>
<li>上記では <code>SELECT COUNT(*) ...</code> としているが、データベース内の全テーブルに同じカラム名で主キーが設定してあるのなら <code>SELECT COUNT(col_name) ...</code> とした方がよい。</li>
</ul>


<p><code>OPTS</code> 以外に追加している <code>-w</code>(or <code>--where</code>) オプションについて。（<strong>今回のポイント</strong>）</p>

<ul>
<li>本来 <code>-w</code> は抽出条件を指定するオプションだが、 WHERE 条件は <code>true</code>（もしくは <code>1</code>） でスルーして <code>LIMIT</code> 句を指定している。<br/>
（mysqldump に LIMIT(OFFSET) 句を指定するオプションが存在しないため）</li>
<li><code>-w "true LIMIT $offset, $DCNT"</code> は <code>-w "true LIMIT $DCNT OFFSET $offset"</code> としてもよい。</li>
<li>主キーやユニークインデックスが歯抜けでなく件数が正確に取得できるのであれば、 <code>-w</code> オプションで LIMIT 句や OFFSET 句を指定せずに普通に条件指定するようにしてもよいだろう。</li>
</ul>


<h3>2. Bash スクリプトの実行</h3>

<p>作業用ディレクトリやダンプファイル格納用サブディレクトリが存在することを確認し、実行権限を付与後に実行する。</p>

<pre><code class="text">$ chmod +x db_dump_only_data_by_split.sh
$ ./db_dump_only_data_by_split.sh
</code></pre>

<p>作業ディレクトリ内のダンプファイル格納用サブディレクトリにダンプファイルが出力され、作業ディレクトリ内にタイムスタンプ付圧縮ファイルが作成されるのを確認する。</p>

<p>また、 LIMIT 句を使用しているのでダンプ出力完了まで時間がかかることを覚悟すること。</p>

<h3>3. その他</h3>

<ul>
<li>データ量が多すぎるとダンプ出力に時間がかかる、ということに留意する。<br/>
<code>-w</code> オプションで LIMIT 句を使用するからと、フルスキャンを避けるために <code>--order-by-primary</code> オプションを使用したり、もしくは <code>-w</code> オプションで <code>ORDER BY</code> 句を指定しても、ダンプ出力が徐々に遅くなる。<br/>
<code>mysqldump</code> の <code>-w</code>(or <code>--where</code>) での LIMIT(OFFSET) 句指定はフルスキャンになってしまうのだろうか？（<code>mysqldump</code> を EXPLAIN で確認できればいいのですが。。。）</li>
<li>データ量が多すぎるとダンプ出力に時間がかかるため、結局当方は、データ量が多すぎる場合は、エクスポートは <code>SELECT INTO ... OUTFILE</code> で CSV 出力、インポートは <code>LOAD DATA INFILE</code> で CSV 取り込み、とすることにした。以下の過去記事を参照。

<ul>
<li><a href="/2011/08/31/31002049/" title="MySQL - SELECT結果をCSV出力！">MySQL - SELECT結果をCSV出力！</a></li>
<li><a href="/2013/06/08/mysql-import-from-csv/" title="MySQL - CSV データインポート！">MySQL - CSV データインポート！</a></li>
</ul>
</li>
</ul>


<h3>4. 参考サイト</h3>

<p>mysqldump の各種オプションや LIMIT 句の指定方法については以下のサイトを参照。</p>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" title="MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program">MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program</a></li>
</ul>


<hr />

<p>結局、当方は今回紹介した方法を積極的には使用していませんが、こういうやり方もあるということを覚えておくと何かの際に役立つかもしれません。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
