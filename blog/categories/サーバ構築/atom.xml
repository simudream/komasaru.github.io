<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: サーバ構築 | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/サーバ構築/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-09-07T00:12:02+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - インデックス名一覧取得！]]></title>
    <link href="http://komasaru.github.io/blog/2015/09/03/mariadb-index-list/"/>
    <updated>2015-09-03T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/09/03/mariadb-index-list</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) で作成済みのインデックスの名称を確認したい場合、 <code>SHOW INDEX FROM table_name</code> を使用することが多いと思います。</p>

<p>しかし、一度に多数のテーブルについて確認したい場合に、テーブル単位で <code>SHOW INDEX FROM table_name</code> を実行するのは大変面倒です。</p>

<p>以下で、指定データベース内の全テーブルに作成済みのインデックスを一覧表示する SQL 等を紹介します。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>MariaDB 10.0.21 での作業を想定。（MySQL でも同様のはず）</li>
</ul>


<h3>1. SQL 作成</h3>

<pre><code class="sql">  SELECT DISTINCT TABLE_SCHEMA, TABLE_NAME, INDEX_NAME
    FROM information_schema.STATISTICS
   WHERE TABLE_SCHEMA = 'scheme_name' -- &lt;= 対象のデータベース名
     AND INDEX_NAME &lt;&gt; 'PRIMARY'
ORDER BY TABLE_SCHEMA, TABLE_NAME, INDEX_NAME;
</code></pre>

<p>ちなみに、インデックスに設定されているカラム名やその順番も確認したければ、以下のような SQL となる。</p>

<pre><code class="sql">  SELECT TABLE_SCHEMA, TABLE_NAME, INDEX_NAME, COLUMN_NAME, SEQ_IN_INDEX
    FROM information_schema.STATISTICS
   WHERE TABLE_SCHEMA = 'scheme_name' -- &lt;= 対象のデータベース名
     AND INDEX_NAME &lt;&gt; 'PRIMARY'
ORDER BY TABLE_SCHEMA, TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;
</code></pre>

<h3>2. 応用</h3>

<p>参考までに、前項で紹介した SQL を利用して、データベース内の全テーブルの全インデックス（プライマリキーを除く）を削除するストアドプロシージャを作成する。<br/>
※当方が過去に必要に迫られて作成したストアドプロシージャで、実際はこのストアドプロシージャ実行後にインデックスを一括作成するストアドプロシージャも実行している。</p>

<pre><code class="sql">CREATE DEFINER=`root`@`localhost` PROCEDURE `del_index_all`()
BEGIN
    -- 変数宣言
    DECLARE v_tbl_name VARCHAR(50) DEFAULT '';
    DECLARE v_idx_name VARCHAR(50) DEFAULT '';
    DECLARE v_done INT DEFAULT 0;
    -- カーソル宣言
    DECLARE v_cur CURSOR FOR
        SELECT
            DISTINCT TABLE_NAME, INDEX_NAME
        FROM
            information_schema.STATISTICS
        WHERE
            TABLE_SCHEMA = 'jmx'
        AND INDEX_NAME &lt;&gt; 'PRIMARY'
        ORDER BY
            TABLE_SCHEMA, TABLE_NAME, INDEX_NAME;
    -- 終了ステータス宣言
    DECLARE EXIT HANDLER FOR NOT FOUND SET v_done = 1;

    -- カーソル OPEN
    OPEN v_cur;

    -- LOOP 処理
    WHILE v_done != 1 DO
        -- カーソル FETCH
        FETCH v_cur INTO v_tbl_name, v_idx_name;

        -- 動的 SQL 実行
        SET @s = CONCAT('ALTER TABLE ', v_tbl_name, ' DROP INDEX ', v_idx_name);
        PREPARE stmt FROM @s;
        EXECUTE stmt;
    END WHILE;

    -- PREPARED STATEMENT 解放
    DEALLOCATE PREPARE stmt;

    -- カーソル CLOSE
    CLOSE v_cur;
END
</code></pre>

<p>本当は、動的に SQL を実行する(PREPARED STATEMENT)部分を以下のようにしたかったが、 <code>?</code> は MariaDB のストアドではサポートされてない模様。（<a href="https://mariadb.com/kb/en/mariadb/prepare-statement/" title="PREPARE Statement - MariaDB Knowledge Base">参考</a>）</p>

<pre><code class="sql">    --  :
    -- 省略
    --  :

    SET @s = 'ALTER TABLE ? DROP INDEX ?';
    PREPARE stmt FROM @s;

    OPEN v_cur;

    WHILE v_done != 1 DO
        FETCH v_cur INTO v_tbl_name, v_idx_name;

        SET @tbl_name = v_tbl_name;
        SET @idx_name = v_idx_name;

        EXECUTE stmt USING @tbl_name, @idx_name;
    END WHILE;

    DEALLOCATE PREPARE stmt;

    CLOSE v_cur;
</code></pre>

<hr />

<p>普段はあまり使用する機会はありませんが、大量のテーブルを再設計する際には有益でしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB 10.0.x - Mroonga プラグインの有効化！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/21/mariadb-mroonga-installation/"/>
    <updated>2015-08-21T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/21/mariadb-mroonga-installation</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>全文検索エンジン Groonga をベースとした MySQL のストレージエンジン Mroonga を MariaDB で使用する方法についての簡単な記録です。</p>

<p>MariaDB 10.0.x では Mroonga のプラグインがバンドルされているので、 Mroonga を別途インストールする必要はありません。<br/>
プラグインを有効にすればすぐに使用できるようになります。（但し、バンドルされている Mroonga はバージョンが少し古いようなので、最新バージョンを使用したければ別途インストールする必要があります）</p>

<p>（Groonga, Mroonga については不勉強で疎いため、乱文ご容赦ください）</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>MariaDB 10.0.21 (on Linux Mint 17.2) での作業を想定。</li>
</ul>


<h3>1. プラグインの有効化</h3>

<p>以下の SQL を実行して、プラグインを有効にする。</p>

<pre><code class="text">&gt; INSTALL PLUGIN Mroonga SONAME 'ha_mroonga.so';
&gt; CREATE FUNCTION last_insert_grn_id RETURNS INTEGER SONAME 'ha_mroonga.so';
&gt; CREATE FUNCTION mroonga_snippet RETURNS STRING SONAME 'ha_mroonga.so';
&gt; CREATE FUNCTION mroonga_command RETURNS STRING SONAME 'ha_mroonga.so';
&gt; CREATE FUNCTION mroonga_escape RETURNS STRING SONAME 'ha_mroonga.so';
</code></pre>

<h3>2. プラグイン有効化の確認</h3>

<pre><code class="text">&gt; SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                                    | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables                  | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears)             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                                      | NO           | NO   | NO         |
| MRG_MyISAM         | YES     | Collection of identical MyISAM tables                                      | NO           | NO   | NO         |
| Mroonga            | YES     | CJK-ready fulltext search, column store                                    | NO           | NO   | NO         |
| FEDERATED          | YES     | FederatedX pluggable storage engine                                        | YES          | NO   | YES        |
| InnoDB             | DEFAULT | Percona-XtraDB, Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |
| Aria               | YES     | Crash-safe tables with MyISAM heritage                                     | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                                     | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
11 rows in set (0.00 sec)
</code></pre>

<h3>3. テーブルの作成方法</h3>

<p>以下は、ストレージモードでテーブルを作成する場合で、 <code>col_name_2</code> に全文検索インデックスを張る例（トークナイザはデフォルトの &ldquo;TokenBigram"）。</p>

<pre><code class="text">&gt; CREATE TABLE table_name(
&gt;   id INT PRIMARY KEY AUTO_INCREMENT,
&gt;   col_name_1 VARCHAR(255),
&gt;   col_name_2 VARCHAR(255),
&gt;   FULLTEXT INDEX (col_name_2)
&gt; ) ENGINE = Mroonga DEFAULT CHARSET utf8;
</code></pre>

<p>以下は、ラッパーモード（元のストレージエンジンは InnoDB）でテーブルを作成する場合で、 <code>col_name_2</code> に全文検索インデックスを張る例（トークナイザはデフォルトの &ldquo;TokenBigram"）。</p>

<pre><code class="text">&gt; CREATE TABLE table_name (
&gt;   id INT PRIMARY KEY AUTO_INCREMENT,
&gt;   col_name_1 VARCHAR(255),
&gt;   col_name_2 VARCHAR(255),
&gt;   FULLTEXT INDEX (col_name_2)
&gt; ) ENGINE = Mroonga COMMENT = 'engine "InnoDB"' DEFAULT CHARSET utf8;
</code></pre>

<p>※但し、 MariaDB では <code>FULLTEXT INDEX</code> で設定しても <code>FULLTEXT KEY</code> で登録される。</p>

<p>ちなみに、テーブルデフォルトのトークナイザを MeCab に変更したい場合は以下のようにする。（設定ファイルで指定することも可能）</p>

<pre><code class="text">&gt; ) ENGINE = Mroonga COMMENT='default_tokenizer "TokenMecab"' DEFAULT CHARSET utf8;
</code></pre>

<p>FULLTEXT INDEX のパーサのみ変更したい場合は以下のようにする。</p>

<pre><code class="text">&gt;   FULLTEXT INDEX (col_name_2) COMMENT='parser "TokenMecab"'
</code></pre>

<h3>4. 検索例</h3>

<p>以下は、テーブル table_name の col_name_2 に「松江」を含み「出雲」を含まないレコードを検索する例。</p>

<pre><code class="sql">&gt; SELECT *, MATCH (col_name_2) AGAINST("+松江 -出雲" IN BOOLEAN MODE)
&gt;   FROM table_name
&gt;  WHERE MATCH (col_name_2) AGAINST("+松江 -出雲" IN BOOLEAN MODE);
</code></pre>

<ul>
<li><code>SELECT</code> 句内の <code>MATCH ... AGAINST ...</code> は、検索スコア。</li>
<li><code>IN BOOLEAN MODE</code> は、マッチ率の概念を省いて、単純にかつ機械的に検索するモード。</li>
</ul>


<p>ちなみに、当方で 30 万件ほどレコードのあるテーブルで同様に検索してみた結果、 <code>WHERE</code> 句を</p>

<pre><code class="sql">WHERE col_name_2 LIKE '%松江%' AND col_name_2 NOT LIKE '%出雲%'
</code></pre>

<p>にして検索するより約 100 倍高速に検索できました。さらに、レコード約 1,300 万件では 約 500 倍高速に検索できました。<br/>
（テーブルレイアウト、レコード数等にもよるでしょうが）</p>

<h3>5. 参考サイト</h3>

<ul>
<li><a href="http://mroonga.org/ja/" title="Mroonga - MySQLで高速全文検索">Mroonga - MySQLで高速全文検索</a></li>
</ul>


<p>中でも、Mroonga プラグインの有効については以下を参照。</p>

<ul>
<li><a href="http://mroonga.org/ja/blog/2015/04/29/release.html" title="Mroonga - Mroonga 5.02リリース！">Mroonga - Mroonga 5.02リリース！</a></li>
</ul>


<hr />

<p>検索の高速化を図るには必須の機能でしょう。</p>

<p>当方も InnoDB で構築している既存の DB の高速化を図ってみたいところです。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AMaViS - エラー(on Debian 8 Jessie)！]]></title>
    <link href="http://komasaru.github.io/blog/2015/07/27/debian-8-amavis-error/"/>
    <updated>2015-07-27T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/07/27/debian-8-amavis-error</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Debian GNU/Linux 8 Jessie で Postfix と AMaViS を連携してメールのウイルスチェックを行うようにしているのですが、メールログにエラーメッセージが出力されていたので、調査して対策を施しました。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Debian GNU/Linux 8.1 Jessie での作業を想定。</li>
<li>アンチウィルスソフト ClamAV を「<a href="/2015/05/29/debian-8-anti-virus-installation/" title="Debian 8 (Jessie) - アンチウィルスソフト導入！">Debian 8 (Jessie) - アンチウィルスソフト導入！</a>」の方法でインストールしていることを想定。</li>
<li>SMTP サーバ Postfix を「<a href="/2015/06/12/debian-8-postfix-installation/" title="Debian 8 (Jessie) - SMTP サーバ Postfix 構築！">Debian 8 (Jessie) - SMTP サーバ Postfix 構築！</a>」の方法でインストールしていることを想定。</li>
<li>Postfix と ClamAV の連携を「<a href="/2015/06/15/debian-8-postfix-cooperation-with-clamav/" title="Debian 8 (Jessie) - Postfix と ClamAV の連携！">Debian 8 (Jessie) - Postfix と ClamAV の連携！</a>」の方法で行なっていることを想定。</li>
</ul>


<h3>1. 現象</h3>

<p>メールログに以下のようなエラーメッセージが出力される。</p>

<pre><code class="text /var/log/mail.log">Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!)run_av (ClamAV-clamd) FAILED - unexpected , output="/var/lib/amavis/tmp/amavis-20150601T105343-28256-JUnFx0XC/parts: lstat() failed: Permission denied. ERROR\n"
Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!)ClamAV-clamd av-scanner FAILED: CODE(0x29c09b0) unexpected , output="/var/lib/amavis/tmp/amavis-20150601T105343-28256-JUnFx0XC/parts: lstat() failed: Permission denied. ERROR\n" at (eval 96) line 905.
Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!)WARN: all primary virus scanners failed, considering backups
Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!)run_av (ClamAV-clamscan) FAILED - unexpected exit 2, output="WARNING: Ignoring unsupported option --recursive (-r)\nWARNING: Ignoring unsupported option --tempdir\n/var/lib/amavis/tmp/amavis-20150601T105343-28256-JUnFx0XC/parts: lstat() failed: Permission denied. ERROR"
Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!)ClamAV-clamscan av-scanner FAILED: /usr/bin/clamdscan unexpected exit 2, output="WARNING: Ignoring unsupported option --recursive (-r)\nWARNING: Ignoring unsupported option --tempdir\n/var/lib/amavis/tmp/amavis-20150601T105343-28256-JUnFx0XC/parts: lstat() failed: Permission denied. ERROR" at (eval 96) line 905.
Jun  1 10:57:36 noah amavis[28256]: (28256-04-7) (!!)AV: ALL VIRUS SCANNERS FAILED
</code></pre>

<h3>2. 原因</h3>

<p>エラーメッセージに出ているとおり、権限がおかしい。</p>

<h3>3. 対策</h3>

<p>3-1 の方法はよくある方法だが、今回注目したかったのは 3-2 の方法。</p>

<h4>3-1. ユーザ ID, グループ ID の確認</h4>

<p><code>id</code> コマンドで clamav, amavis のユーザ ID, グループ ID を確認する。</p>

<pre><code class="text"># id clamav
uid=108(clamav) gid=113(clamav) groups=113(clamav),123(amavis)

# id amavis
uid=115(amavis) gid=123(amavis) groups=123(amavis)
</code></pre>

<p>clamav ユーザが amavis グループに属していれば、それでよい。</p>

<p>clamav ユーザが amavis グループに属していなければ、以下のようにして amavis グループに追加する。（<code>-a</code> オプションは重要。このオプションを付け忘れると clamav ユーザが既に属していたグループから外れてしまう）</p>

<pre><code class="text"># usermod -a -G amavis clamav
</code></pre>

<p>clamav ユーザを amavis グループに追加した場合は、 clamav-daemon, amavis, postfix を再起動する。</p>

<pre><code class="text"># systemctl restart clamav-daemon
# systemctl restart amavis
# systemctl restart postfix
</code></pre>

<h4>3-2. clamd.conf の編集</h4>

<p>前項 3-1 の方法でもエラーが解消しない場合は、 ClamAV Daemon 設定ファイル &ldquo;clamd.conf&rdquo; の <code>AllowSupplementaryGroups</code> を確認してみる。</p>

<p><code>false</code> になっていた場合は <code>true</code>（グループ権限も移譲）に変更する。</p>

<pre><code class="bash /etc/clamav/clamd.conf">AllowSupplementaryGroups true  # &lt;= false を true に変更
</code></pre>

<p>そして、 clamav-daemon, amavis, postfix を再起動する。（起動順に注意すべき旨を紹介しているサイトもあるが、起動順が影響しているか否かは当方未確認）</p>

<pre><code class="text"># systemctl restart clamav-daemon
# systemctl restart amavis
# systemctl restart postfix
</code></pre>

<hr />

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux & Ruby - メール受信時の処理！]]></title>
    <link href="http://komasaru.github.io/blog/2015/07/21/linux-ruby-process-when-mail-received/"/>
    <updated>2015-07-21T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/07/21/linux-ruby-process-when-mail-received</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Linux 上に構築したメールサーバで、メール受信をトリガにして処理を実行する手順等についての記録です。<br/>
処理は Ruby で行うことを想定しています。（多くのサイト等では Perl や PHP での処理がよく紹介されてます）</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Debian GNU/Linux 8.1 での作業を想定。</li>
<li>Ruby 2.2.2-95 での作業を想定。</li>
<li>SMTP サーバ Postfix 構築済み。

<ul>
<li>参考「<a href="/2015/06/12/debian-8-postfix-installation/" title="Debian 8 (Jessie) - SMTP サーバ Postfix 構築！">Debian 8 (Jessie) - SMTP サーバ Postfix 構築！</a>」</li>
</ul>
</li>
<li>POP/IMAP サーバ Dovecot 構築済み。

<ul>
<li>参考「<a href="/2015/06/13/debian-8-dovecot-installation/" title="Debian 8 (Jessie) - POP/IMAP サーバ Dovecot 構築！">Debian 8 (Jessie) - POP/IMAP サーバ Dovecot 構築！</a>」</li>
</ul>
</li>
<li>Postfix の aliases （メール転送機能）と連携をとる方法を想定。</li>
<li>処理対象のユーザ・グループは &ldquo;test&rdquo;, &ldquo;test&rdquo; を想定。</li>
</ul>


<h3>1. Ruby スクリプトの作成</h3>

<p>以下のような Ruby スクリプトを作成する。<br/>
（紹介用に受信したメールを解析してテキストファイルに保存するだけのプログラム）</p>

<pre><code class="ruby get_mail.rb">#! /usr/local/bin/ruby
# coding: utf-8
#-------------------------------------------------
# Ruby script to get a mail via alias of postfix.
#-------------------------------------------------
require 'mail'

class GetMail
  def initialize
    dt = Time.now.strftime("%Y%m%d_%H%M%S%L")
    @out_file = "/path/to/#{dt}.txt"
  end

  def execute
    open(@out_file, "w") do |f|
      mail = Mail.new($stdin.read)
      f.puts "From:    #{mail.from.first}"
      f.puts "To:      #{mail.to.first}"
      f.puts "Date:    #{mail.date}"
      f.puts "Subject: #{mail.subject}"
      f.puts "Body:\n#{mail.body.decoded.encode("UTF-8", mail.charset)}"
    end
  rescue =&gt; e
    $stderr.puts "[#{e.class}] #{e.message}"
    e.backtrace.each{|trace| $stderr.puts "\t#{trace}"}
    exit 1
  end
end

exit unless $0 == __FILE__
GetMail.new.execute
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/0cbfe02794efa4c1a09e" title="Gist - Ruby script to get a mail via alias of postfix.">Gist - Ruby script to get a mail via alias of postfix.</a></li>
</ul>


<h3>2. Ruby スクリプトの配置</h3>

<p>作成した Ruby スクリプトをサーバ上の適当な位置に配置する。<br/>
（今回、当方は処理を行いたいユーザの home ディレクトリ &ldquo;/home/test&rdquo; 直下に配置した（所有者 &ldquo;test&rdquo; で））</p>

<p>配置後、実行権限を付与する。</p>

<pre><code class="text"># chmod +x get_mail.rb
</code></pre>

<h3>3. メール保存用ディレクトリの作成</h3>

<p>今回の処理で使用するディレクトリをサーバ上の適当な位置に作成する。<br/>
（今回、当方は処理を行いたいユーザの home ディレクトリ &ldquo;/home/test&rdquo; 配下に &ldquo;get_mail&rdquo; ディレクトリを作成した（所有者 &ldquo;test&rdquo; で））</p>

<h3>4. Postfix の aliases 設定</h3>

<pre><code class="bash /etc/aliases">test:  :include:/home/test/alias_inc
</code></pre>

<p>ちなみに、処理を行う他に転送も行いたい場合は、以下のようにカンマで区切ればよい。</p>

<pre><code class="bash /etc/aliases">test:  hoge, :include:/home/test/alias_inc
</code></pre>

<h3>5. include ファイル（実行コマンド）の作成</h3>

<pre><code class="text /home/test/alias_inc">"| /home/test/get_mail.rb"
</code></pre>

<p>そして、このファイルの所有者が &ldquo;test&rdquo; でなければ &ldquo;test&rdquo; にする。</p>

<pre><code class="text"># chown test. /home/test/alias_inc
</code></pre>

<h3>6. Postfix 設定ファイル main.cf の編集</h3>

<p>&ldquo;/etc/aliases&rdquo; ファイル内で <code>:include:</code> を使用する際は、Postfix の設定ファイル &ldquo;main.cf&rdquo; に以下のように追記しなければならない。<br/>
（Postfix は、デフォルトでは <code>:include:</code> での &ldquo;|command&rdquo; への配送を認めていないため）</p>

<pre><code class="bash /etc/postfix/main.cf">allow_mail_to_commands = alias,forward,include
</code></pre>

<h3>7. Postfix 設定のリロード</h3>

<pre><code class="text"># systemctl reload postfix
</code></pre>

<h3>8. aliases の設定反映</h3>

<pre><code class="text"># newaliases
</code></pre>

<h3>9. 動作確認</h3>

<p>実際に test ユーザ宛にメールを送信してみて、指定のディレクトリ配下に保存されること、内容が適切であることを確認する。</p>

<h3>10. その他</h3>

<p>上記の 4, 5, 6 でエイリアスを別ファイルに分けてインクルードしている。<br/>
これは、"/etc/aliases" 内で直接コマンドを指定すると作成されるファイルの所有者・グループが &ldquo;nobody:nogroup&rdquo; になってしまうのを防ぐためである。</p>

<h3>11. 参考サイト</h3>

<ul>
<li><a href="http://www.postfix-jp.info/trans-2.3/jhtml/aliases.5.html" title="Postfix manual - aliases(5)">Postfix manual - aliases(5)</a></li>
</ul>


<hr />

<p>当方は、Linux サーバに Twitter ツイート専用のユーザを作成し、そのユーザ宛に配送されたメール本文をツイートするように応用しています。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB - レプリケーション設定（GTID 使用）！]]></title>
    <link href="http://komasaru.github.io/blog/2015/07/18/mariadb-replication-by-gtid/"/>
    <updated>2015-07-18T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/07/18/mariadb-replication-by-gtid</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>従来からあるレプリケーションとは異なる GTID(Global Transaction ID) を使用したレプリケーション設定の記録です。</p>

<p>MySQL とは実装自体が異なるため、MySQL と若干設定の異なる部分もあります。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Master 側、Slave 側ともに MariaDB 10.0.20 を想定。</li>
<li>Master 側は既存のサーバ、Slave 側は今回新規に構築したばかりのサーバを想定。<br/>
（Slave 側も既存のサーバの場合は、 &ldquo;ibdata1&rdquo;, &ldquo;ib_logfile0&rdquo;, &ldquo;ib_logfile1&rdquo; ファイルを削除(DISCARD)する作業が必要かも）</li>
<li>レプリケーション用のユーザは &ldquo;repl&rdquo; を想定。</li>
<li>ストレージエンジンは InnoDB を想定。</li>
<li>GTID(Global Transaction ID) がどんなものであるかは、ここでは説明しない。</li>
<li>以下の説明で出現する設定ファイルは、環境によりパスやファイル名が異なるかもしれないので、適宜置き換えること。</li>
</ul>


<h3>1. [Master] 設定ファイルの編集</h3>

<p>MariaDB 設定ファイル &ldquo;/etc/mysql/conf.d/mariadb.cnf&rdquo; を編集する。</p>

<pre><code class="bash /etc/mysql/conf.d/mariadb.cnf">server-id = 1           # &lt;= ネットワーク内で重複しないよに設定
log-bin = mariadb-bin   # &lt;= バイナリログを設定（名前は任意）
bind-address = 0.0.0.0  # &lt;= 変更（Slave 側からもアクセスできるようにする）
                        #    もしくは、`::`
                        #    もしくは、コメントアウト
</code></pre>

<h3>2. [Master] MariaDB サーバの再起動</h3>

<pre><code class="text"># systemctl restart mysql
</code></pre>

<h3>3. [Master] レプリケーション用ユーザの作成</h3>

<p>MariaDB サーバに root でログインし、レプリケーション用（Slave 側から Master 側にログインするための）ユーザを作成する。</p>

<pre><code class="text">&gt; GRANT REPLICATION SLAVE ON *.* TO repl@'Slave 側のホスト名 or IP アドレス' IDENTIFIED BY 'repl のパスワード';
&gt; FLUSH PRIVILEGES;
</code></pre>

<h3>4. [Master] DB ダンプファイルの出力</h3>

<p>全データベースのダンプファイルを出力する。</p>

<pre><code class="text"># mysqldump -u root -p --all-databases --single-transaction --master-data=2 &gt; master.sql
</code></pre>

<p><code>--master-data=2</code> は、ダンプファイルに <code>-- CHANGE MASTER TO MASTER_LOG_FILE=...</code> を出力するオプション。</p>

<h3>5. [Master] GTID の取得</h3>

<p>前項で取得したダンプファイルの <code>-- CHANGE MASTER TO MASTER_LOG_FILE=...</code> を確認し、バイナリログファイル名とポジションを控える。（ダンプファイルのサイズが大きい場合は、テキストエディタで開くのに注意！）</p>

<pre><code class="text"># head -n 30 master.sql | grep MASTER_LOG_FILE
-- CHANGE MASTER TO MASTER_LOG_FILE='mariadb-bin.000009', MASTER_LOG_POS=330;
</code></pre>

<p>そして、MariaDB サーバに root でログイン後に以下を実行して GTID ポジションを取得し、控えておく。</p>

<pre><code class="text">+--------------------------------------------+
| BINLOG_GTID_POS('mariadb-bin.000009', 330) |
+--------------------------------------------+
| 0-2-10521                                  |
+--------------------------------------------+
1 row in set (0.03 sec)
</code></pre>

<h3>6. [Slave] DB ダンプファイルのリストア</h3>

<p>Master 側で出力した DB ダンプファイルを何かしらの方法で Slave 側へ移動し、リストアする。</p>

<pre><code class="text"># mysql -u root -p &lt; master.sql
</code></pre>

<h3>7. [Slave] 設定ファイルの編集</h3>

<p>MariaDB 設定ファイル &ldquo;/etc/mysql/conf.d/mariadb.cnf&rdquo; を編集する。</p>

<pre><code class="text /etc/mysql/conf.d/mariadb.cnf">server-id = 2          # &lt;= ネットワーク内で重複しないように設定
log-bin = mariadb-bin  # &lt;= バイナリログを設定（名前は任意）
</code></pre>

<h3>8. [Slave] MariaDB サーバの再起動</h3>

<pre><code class="text"># systemctl restart mysql
</code></pre>

<h3>9. [Slave] レプリケーションの設定</h3>

<p>MariaDB サーバに root でログインし、以下のように実行する。</p>

<pre><code class="sql">&gt; SET GLOBAL gtid_slave_pos = '0-2-10521';  # &lt;= 3 で取得した GTID を指定
Query OK, 0 rows affected (0.32 sec)

&gt; CHANGE MASTER TO
    -&gt; master_host = 'Master 側のホスト名 or IPアドレス',
    -&gt; master_user = 'repl',
    -&gt; master_password = 'repl のパスワード',
    -&gt; master_use_gtid = slave_pos;
Query OK, 0 rows affected (0.23 sec)
</code></pre>

<h3>10. [Slave] レプリケーションの開始</h3>

<p>続けて、以下のように実行する。</p>

<pre><code class="text">&gt; START SLAVE;
Query OK, 0 rows affected (0.18 sec)
</code></pre>

<p>ちなみに、レプリケーションを停止するには、以下のように実行する。</p>

<pre><code class="text">&gt; STOP SLAVE;
</code></pre>

<p>ステータスは以下で確認できる。</p>

<pre><code class="text">&gt; SHOW SLAVE STATUS\G
</code></pre>

<h3>11. 動作確認</h3>

<p>Master 側への INSERT, UPDATE, DELETE 等が Slave 側にも反映されることを確認する。</p>

<h3>12. レプリケーションの完全停止設定</h3>

<p>レプリケーションの完全に停止（一時的な停止でなく、機能そのものを削除）するには、 Slave 側で以下を実行後に MariaDB サーバを再起動すればよい。</p>

<pre><code class="text">&gt; STOP SLAVE;
&gt; RESET SLAVE ALL;
</code></pre>

<p>（<code>RESET SLAVE</code> だと HOST, USER, PASSWORD はリセットされない）</p>

<p>ちなみに、MySQL の古いバージョンだと、以下を実行後に MariaDB サーバを再起動すればよい。（当方、未確認）</p>

<pre><code class="text">&gt; STOP SLAVE;
&gt; RESET SLAVE;
&gt; CHANGE MASTER TO MASTER_HOST='';
</code></pre>

<p>また、このレプリケーション停止設定をしなければ、 <code>STOP SLAVE</code> をしても MariaDB サーバ再起動時に Slave が開始されてしまう。</p>

<h3>13. 参考サイト</h3>

<ul>
<li><a href="https://mariadb.com/kb/en/mariadb/standard-replication/" title="Standard Replication - MariaDB Knowledge Base">Standard Replication - MariaDB Knowledge Base</a></li>
</ul>


<hr />

<p>GTID を使用したレプリケーションにはメリット・デメリットがあります。<br/>
よく理解した上で運用すると、サーバ運用が効率化されるのではないでしょうか。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
