<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: サーバ構築 | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/サーバ構築/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-11-05T00:30:03+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CentOS 6.7 - Postfix ウィルス対策(ClamAV + ClamSMTP)！]]></title>
    <link href="http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation/"/>
    <updated>2015-11-05T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/11/05/centos-clamsmtp-installation</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>送信メールサーバ Postfix と Clam AntiVirus を ClamSMTP で連携してメールのウィルスチェックを行う方法についての記録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.7(32bit) での作業を想定。</li>
<li>EPEL リポジトリ導入済み。（参考「<a href="/2013/12/13/centos-6-5-first-setting/" title="CentOS 6.5 - 初期設定！">CentOS 6.5 - 初期設定！</a>」）</li>
<li>SMTP サーバ Postfix 構築済み。</li>
<li>アンチウィルスソフト ClamAV(<code>clamd</code>) 導入済み。</li>
</ul>


<h3>1. ClamSMTP のインストール</h3>

<pre><code class="text"># yum --enablerepo=epel -y install clamsmtp
</code></pre>

<h3>2. ClamSMTP 設定ファイルの編集</h3>

<pre><code class="bash /etc/clamsmtpd.conf">Listen: 0.0.0.0:10025                           # &lt;= コメント解除

Header: X-Virus-Scanned: ClamAV using ClamSMTP  # &lt;= コメント解除

Action: drop                                    # &lt;= コメント解除
</code></pre>

<h3>3. ClamSMTP の起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/clamsmtpd start
Starting ClamSmtpd:                                        [  OK  ]

# /etc/rc.d/init.d/clamsmtp-clamd start
</code></pre>

<h3>4. ClamSMTP 自動起動の設定</h3>

<pre><code class="text"># chkconfig clamsmtpd on
# chkconfig clamsmtp-clamd on
# chkconfig --list clamsmtpd
clamsmtpd       0:off   1:off   2:on    3:on    4:on    5:on    6:off
# chkconfig --list clamsmtp-clamd
clamsmtp-clamd  0:off   1:Off   2:on    3:on    4:on    5:on    6:off
</code></pre>

<h3>5. Postfix 設定ファイルの編集</h3>

<pre><code class="bash /etc/postfix/main.cf"># 以下を最終行へ追記
content_filter = scan:127.0.0.1:10025
</code></pre>

<pre><code class="bash /etc/postfix/master.cf"># 以下を最終行へ追記
scan unix -       -       n       -       16       smtp
   -o smtp_data_done_timeout=1200
   -o smtp_send_xforward_command=yes
   -o disable_dns_lookups=yes
127.0.0.1:10026 inet n       -       n       -       16       smtpd
   -o content_filter=
   -o local_recipient_maps=
   -o relay_recipient_maps=
   -o smtpd_restriction_classes=
   -o smtpd_client_restrictions=
   -o smtpd_helo_restrictions=
   -o smtpd_sender_restrictions=
   -o smtpd_recipient_restrictions=permit_mynetworks,reject
   -o mynetworks_style=host
   -o smtpd_authorized_xforward_hosts=127.0.0.0/8
</code></pre>

<ul>
<li>上記の <code>10026</code> は &ldquo;/etc/clamsmtpd.conf&rdquo; の <code>OutAddress</code> の値に合わせる。</li>
</ul>


<h3>6. Postfix の再起動</h3>

<pre><code class="text"># /etc/rc.d/init.d/postfix restart
Shutting down postfix:                  [  OK  ]
Starting postfix:                       [  OK  ]
</code></pre>

<h3>7. 動作確認</h3>

<p>メールを自分宛に送信してみて受信したメールのヘッダに以下のような記述があるか確認する。</p>

<pre><code class="text">X-Virus-Scanned: ClamAV using ClamSMTP
</code></pre>

<p>また、ウィルスメールを送信してみて受信しないことも確認する。（例えば、本文に以下（テストウィルス）を記載したメールを送信）</p>

<pre><code class="text">X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
</code></pre>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.server-world.info/query?os=CentOS_6&amp;p=mail&amp;f=6" title="CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World">CentOS 6 - MAILサーバー - Clamav との連携 - ClamSMTP ： Server World</a></li>
</ul>


<hr />

<p>送信メールサーバ Postfix と Clam AntiVirus を AMaVisd-new で連携する場合と比べてどうなのか？ということを体感してみたかった故の今回の試行でした。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - データのみを指定件数ずつ分割ダンプ出力！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split/"/>
    <updated>2015-10-26T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/26/mariadb-dump-only-data-by-split</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) の指定したデータベースを、テーブル別にデータのみを指定件数ずつ分割してダンプ出力する方法についてです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>MariaDB 10.0.21 サーバでの作業を想定。（MySQL や他のバージョンでも同様（のはず））</li>
<li>Bash スクリプトを作成して実現させる。</li>
<li>出力されたダンプファイルはまとめて圧縮保存する。</li>
<li>必要であれば、「<a href="/2014/06/15/mysql-dump-only-schema-data-stored/" title="MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！">MySQL(MariaDB) - スキーマのみ、データのみ、ストアド・トリガーのみのダンプ！</a>」も参考にしてください。</li>
<li>以下で紹介する Bash スクリプトでは、トランザクションの単位がテーブル・ループ単位となるため、<strong>データの整合性に注意</strong>。<br/>
（<strong>ダンプ出力時やリストア時に DB への挿入・更新・削除がないことが前提</strong>）</li>
</ul>


<h3>1. Bash スクリプトの作成</h3>

<p>以下は、当方がデータのみを分割ダンプ出力する際に使用している Bash スクリプトである。（解説はスクリプト内のコメントにて。 <code>(*)</code> はさらなる説明を後述）</p>

<pre><code class="bash db_dump_only_data_by_split.sh">#!/bin/bash

# 定数定義
DB=db_name                      # データベース・スキーマ名
USER=user_name                  # ダンプ出力するユーザ名
PW=user_password                #       〃      ユーザ名のパスワード
CMD=/usr/bin/mysqldump          # mysqldump コマンドのフルパス
WK_DIR=/path/to/backup_mysql    # 作業ディレクトリ
DMP_DIR=$WK_DIR/tabledatas_$DB  # ダンプファイル格納ディレクトリ
OPTS="-t -Q -F --skip-lock-tables --skip-triggers --skip-dump-date --single-transaction"
                                # mysqldump オプション(*)
DCNT=100000                     # 分割するレコード件数

# ダンプファイルクリア
rm -f $DMP_DIR/*

# DB 内に存在するテーブル毎にループ処理
for tbl in `mysql -u $USER -p$PW -N -s -e "show tables in $DB;"`; do
  # テーブル内に存在するレコード件数(*)
  rows=`mysql -u $USER -p$PW $DB -N -B -e "SELECT COUNT(*) FROM $tbl;"`
  echo "* $tbl [$rows records]"

  # レコード件数から分割数を算出してループ処理
  for ((i = 0; i &lt;= $(($rows / $DCNT)); i++))
  do
    # 出力ダンプファイル名
    fname=$(printf ${tbl}_%02d $i)
    # オフセット算出
    offset=$((i * $DCNT))
    echo "  $fname [OFFSET: $offset]"
    # ダンプ出力(*)
    $CMD -u $USER -p$PW $DB $tbl $OPTS -w "true LIMIT $offset, $DCNT"&gt; $DMP_DIR/$fname.sql
  done;
done;

# タイムスタンプ付ファイル名で圧縮保存
cd $WK_DIR
dt=`date '+%Y%m%d_%H%M%S'`
tar zcvf ${DB}_tabledata_$dt.tar.gz tabledatas_$DB
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/d9cae95bf4d30da5545b" title="Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.">Gist - Bash script to dump only records of MariaDB(MySQL) tables by split.</a></li>
</ul>


<p>mysqldump オプション（上記の<code>OPTS</code>）について。（mysqldump のデフォルトで有効のオプション <code>--opt</code> とは別のもの）</p>

<ul>
<li><code>-t</code>(or <code>--no-create-info</code>) &hellip; テーブル作成（CREATE TABLE）文を出力しないオプション。</li>
<li><code>-Q</code>(or <code>--quote-names</code>) &hellip; データベース名、テーブル名、カラム名を <code>`</code> で囲むオプション（デフォルトで有効）。</li>
<li><code>-F</code>(or <code>--flush-logs</code>) &hellip; ダンプ開始前にログファイルをフラッシュするオプション。</li>
<li><code>--skip-lock-tables</code> &hellip; デフォルトで有効になる全テーブルをロックするオプション <code>--lock-tables</code> を無効にするオプション。</li>
<li><code>--skip-triggers</code> &hellip; trigger のダンプ出力を無効にするオプション。</li>
<li><code>--skip-dump-date</code> &hellip; ダンプ日時の出力を無効にするオプション。</li>
<li><code>--single-transaction</code> &hellip; データの整合性を保つためにダンプ処理をトランザクションで囲むオプション。</li>
<li>ちなみに、主キーでソートせずに LIMIT(OFFSET) 句を使用するとフルスキャンになってしまうからと、 <code>--order-by-primary</code> という主キーでソートするオプションを使用すると、 Syntax error が発生しまう。従って、今回は使用していない。<br/>
主キーでソートしたければ、 <code>-w</code> オプションの <code>LIMIT</code> 句の前に <code>ORDER BY primary_key_col</code> のように追加する。（但し、今回紹介のケースでは DB 内全テーブルの主キーが同じカラムである必要がある）</li>
</ul>


<p>レコード件数取得について。</p>

<ul>
<li>上記では <code>SELECT COUNT(*) ...</code> としているが、データベース内の全テーブルに同じカラム名で主キーが設定してあるのなら <code>SELECT COUNT(col_name) ...</code> とした方がよい。</li>
</ul>


<p><code>OPTS</code> 以外に追加している <code>-w</code>(or <code>--where</code>) オプションについて。（<strong>今回のポイント</strong>）</p>

<ul>
<li>本来 <code>-w</code> は抽出条件を指定するオプションだが、 WHERE 条件は <code>true</code>（もしくは <code>1</code>） でスルーして <code>LIMIT</code> 句を指定している。<br/>
（mysqldump に LIMIT(OFFSET) 句を指定するオプションが存在しないため）</li>
<li><code>-w "true LIMIT $offset, $DCNT"</code> は <code>-w "true LIMIT $DCNT OFFSET $offset"</code> としてもよい。</li>
<li>主キーやユニークインデックスが歯抜けでなく件数が正確に取得できるのであれば、 <code>-w</code> オプションで LIMIT 句や OFFSET 句を指定せずに普通に条件指定するようにしてもよいだろう。</li>
</ul>


<h3>2. Bash スクリプトの実行</h3>

<p>作業用ディレクトリやダンプファイル格納用サブディレクトリが存在することを確認し、実行権限を付与後に実行する。</p>

<pre><code class="text">$ chmod +x db_dump_only_data_by_split.sh
$ ./db_dump_only_data_by_split.sh
</code></pre>

<p>作業ディレクトリ内のダンプファイル格納用サブディレクトリにダンプファイルが出力され、作業ディレクトリ内にタイムスタンプ付圧縮ファイルが作成されるのを確認する。</p>

<p>また、 LIMIT 句を使用しているのでダンプ出力完了まで時間がかかることを覚悟すること。</p>

<h3>3. その他</h3>

<ul>
<li>データ量が多すぎるとダンプ出力に時間がかかる、ということに留意する。<br/>
<code>-w</code> オプションで LIMIT 句を使用するからと、フルスキャンを避けるために <code>--order-by-primary</code> オプションを使用したり、もしくは <code>-w</code> オプションで <code>ORDER BY</code> 句を指定しても、ダンプ出力が徐々に遅くなる。<br/>
<code>mysqldump</code> の <code>-w</code>(or <code>--where</code>) での LIMIT(OFFSET) 句指定はフルスキャンになってしまうのだろうか？（<code>mysqldump</code> を EXPLAIN で確認できればいいのですが。。。）</li>
<li>データ量が多すぎるとダンプ出力に時間がかかるため、結局当方は、データ量が多すぎる場合は、エクスポートは <code>SELECT INTO ... OUTFILE</code> で CSV 出力、インポートは <code>LOAD DATA INFILE</code> で CSV 取り込み、とすることにした。以下の過去記事を参照。

<ul>
<li><a href="/2011/08/31/31002049/" title="MySQL - SELECT結果をCSV出力！">MySQL - SELECT結果をCSV出力！</a></li>
<li><a href="/2013/06/08/mysql-import-from-csv/" title="MySQL - CSV データインポート！">MySQL - CSV データインポート！</a></li>
</ul>
</li>
</ul>


<h3>4. 参考サイト</h3>

<p>mysqldump の各種オプションや LIMIT 句の指定方法については以下のサイトを参照。</p>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" title="MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program">MySQL :: MySQL 5.6 Reference Manual :: 4.5.4 mysqldump — A Database Backup Program</a></li>
</ul>


<hr />

<p>結局、当方は今回紹介した方法を積極的には使用していませんが、こういうやり方もあるということを覚えておくと何かの際に役立つかもしれません。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - スワップ領域の作成！]]></title>
    <link href="http://komasaru.github.io/blog/2015/10/20/linux-create-swap-area/"/>
    <updated>2015-10-20T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/10/20/linux-create-swap-area</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>スワップ領域の容量が不足した際に追加で作成する方法についてです。</p>

<p>本来なら物理メモリを増設すべきでしょうが、それまでの緊急的な措置としてスワップファイルを作成してそれをスワップ領域に割り当てるのです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>CentOS 6.6(32bit) での作業を想定。（他のディストリビューションでも同じ）</li>
</ul>


<h3>1. スワップファイルの作成</h3>

<p>以下は、ブロックサイズ 1KB で 2GB(1024 x 1024 x 2ブロック) のスワップ領域用のファイルを作成する例。</p>

<pre><code class="text"># dd if=/dev/zero of=/var/tmp/swap bs=1024 count=2097152
2097152+0 records in
2097152+0 records out
2147483648 bytes (2.1 GB) copied, 74.8475 s, 28.7 MB/s
</code></pre>

<h3>2. スワップ領域の作成</h3>

<p>先ほど作成したスワップファイルをスワップ領域に割り当てる。</p>

<pre><code class="text"># mkswap /var/tmp/swap
mkswap: /var/tmp/swap: warning: don't erase bootbits sectors
        on whole disk. Use -f to force.
スワップ空間バージョン1を設定します、サイズ = 2097148 KiB
ラベルはありません, UUID=1a802279-4f23-4466-8579-fa38a2cc4d5a
</code></pre>

<ul>
<li>スワップ領域を作成する前にデバイスの不良ブロックのチェックを行いたい場合は、 <code>-c</code> オプションを使用する。<br/>
（不良ブロックを検出した場合は、その件数が出力される）</li>
<li>スワップファイルにラベルを指定する（ラベル指定でスワップ領域の有効化したい）場合は、 <code>-L</code> オプションで指定する。</li>
</ul>


<h3>3. スワップ領域の有効化</h3>

<p>先ほど作成したスワップ領域を有効化する。</p>

<pre><code class="text"># swapon /var/tmp/swap
</code></pre>

<ul>
<li>当然ながら、スワップファイルではなくパーティションを指定することも可能。</li>
<li>スワップファイル名でなくラベルで指定することも可能。</li>
<li>優先度を指定したければ、 <code>-p priority</code> で指定する。 <code>priority</code> は 0 〜 32767 の数値で、大きいほど優先度が高い。</li>
<li>同じ優先度のスワップ領域が複数ある場合、ページがラウンド・ロビン方式で配分される。</li>
</ul>


<h3>4. スワップ領域の確認</h3>

<p>スワップ領域の一覧を確認するには以下のようにする。（以下は一例）</p>

<pre><code class="text"># swapon -s
Filename                                Type            Size    Used    Priority
/dev/sda2                               partition       2097148 766580  -1
/var/tmp/swap                           file            2097148 0       -2
</code></pre>

<ul>
<li>優先度を指定しない場合、自動で既存スワップ領域で最低の優先度に続く優先度になるのではなかろうか。</li>
</ul>


<h3>5. スワップ領域の削除</h3>

<p>スワップが不要になった場合は以下のようにして削除する。</p>

<pre><code class="text"># swapoff /var/tmp/swap
</code></pre>

<ul>
<li>当然ながら、スワップファイルではなくパーティションを指定することも可能。</li>
<li>スワップファイル名でなくラベルで指定することも可能。</li>
</ul>


<h3>6. スワップファイルの削除</h3>

<p>完全にスワップ領域が不要なら、スワップファイルも削除する。（単純なファイル削除）</p>

<pre><code class="text"># rm -f /var/tmp/swap
</code></pre>

<h3>7. 自動マウント</h3>

<p>マシン起動時に自動でスワップ領域を有効化したい場合は、 &ldquo;/etc/fstab&rdquo; に以下のように追記する。</p>

<pre><code class="text /etc/fstab">/var/tmp/swap         swap    swap    sw    0 0
</code></pre>

<ul>
<li>1列目 &hellip; デバイス名・スワップファイル名</li>
<li>2列目 &hellip; マウントポイント（スワップ領域にはマウントポイントがないので <code>none</code> でもよい）</li>
<li>3列目 &hellip; ファイルシステム</li>
<li>4列目 &hellip; マウント時のオプション（<code>defaults</code> でもよい。優先度を指定するなら <code>sw,pri=X</code>（<code>X</code> は <code>0</code> 〜 <code>32767</code> の数値））</li>
<li>5列目 &hellip; ファイルシステムを dump する必要があるか否かの指定（<code>0</code> は dump の必要なし）</li>
<li>6列目 &hellip; システム起動時に fsck チェックを行うか否かの指定（<code>0</code> は fsck チェックを行わない）</li>
</ul>


<hr />

<p>これで取り急ぎのスワップ領域拡大ができますが、この間に物理メモリ増設について検討しましょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postfix - メールキューの管理！]]></title>
    <link href="http://komasaru.github.io/blog/2015/09/17/postfix-management-of-mail-queue/"/>
    <updated>2015-09-17T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/09/17/postfix-management-of-mail-queue</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>SMTP サーバ Postfix でのメールキュー管理についての備忘録です。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Debian GNU/Linux 8.0(64bit) 上の Postfix 2.11.3-1,<br/>
CentOS 6.7(32bit) 上の Postfix 2.6.6.-2<br/>
での作業を想定。</li>
</ul>


<h3>1. 各種コマンド</h3>

<h4>1-1. メールキューの確認</h4>

<p>配送されずに溜まっているメールキューは &ldquo;/var/spool/postfix/deferred&rdquo; ディレクトリ内にある。<br/>
それらを確認するには以下のようにする。</p>

<pre><code class="text">$ postqueue -p
-Queue ID- --Size-- ----Arrival Time---- -Sender/Recipient-------
AF70A2C009D*    1504 Sat Aug 22 23:57:39 hoge@xxxxxxxxxx.com
                                         fuga@yyyyyyyyyy.com

-- 2 Kbytes in 1 Request.
</code></pre>

<p>もしくは、</p>

<pre><code class="text">$ mailq
</code></pre>

<h4>1-2. メール内容の確認</h4>

<pre><code class="text">$ postcat -q &lt;QueueID&gt;
</code></pre>

<h4>1-3. メールキュー配送の停止</h4>

<pre><code class="text">$ postsuper -h &lt;QueueID&gt;|ALL
</code></pre>

<h4>1-4. メールキューの削除</h4>

<pre><code class="text">$ postsuper -d &lt;QueueID&gt;|ALL
</code></pre>

<p>配送が遅れいているキュー全てを削除する場合は、</p>

<pre><code class="text">$ postsuper -d ALL deferred
</code></pre>

<h4>1-5. メールキューの再送</h4>

<pre><code class="text">$ postsuper -r &lt;QueueID&gt;|ALL
</code></pre>

<p>もしくは、</p>

<pre><code class="text">$ postfix flush
</code></pre>

<p>もしくは、</p>

<pre><code class="text">postqueue -f
</code></pre>

<p>もしくは、</p>

<pre><code class="text">sendmail -q
</code></pre>

<hr />

<p>時々使用するコマンドなので、忘れたときのために記録しておいた次第です。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB(MySQL) - XML ダンプ出力から HTML テーブル定義書生成！]]></title>
    <link href="http://komasaru.github.io/blog/2015/09/12/mariadb-table-definition-from-xmldump-to-html/"/>
    <updated>2015-09-12T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/09/12/mariadb-table-definition-from-xmldump-to-html</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>MariaDB(MySQL) のテーブル定義書を HTML で生成する方法についての記録です。</p>

<p>実際には、スキーマ（テーブル定義）を XML 出力し、それに XSL テンプレートを適用します。</p>

<p>（テーブル定義を行なってからテーブルを作成するのが本来の手順でしょうが）</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>MariaDB 10.0.21 サーバでの作業を想定。</li>
<li>HTML 生成に <code>xsltproc</code> コマンドを使用するので、未インストールならインストールしておく。</li>
</ul>


<h3>1. XML ダンプ出力</h3>

<p><code>mysqldump</code> コマンドを使用してスキーマ（テーブル定義）のみを XML フォーマットで出力する。<br/>
（以下は <code>test</code> というデータベースの <code>towns</code> というテーブルを &ldquo;test_towns.xml&rdquo; という XML ファイルに出力する例）</p>

<pre><code class="text">$ mysqldump -u username -p --xml --no-data test towns &gt; test_towns.xml
</code></pre>

<p>参考までに、今回出力された XML ファイルの内容は以下のとおり。</p>

<pre><code class="xml text.xml">&lt;?xml version="1.0"?&gt;
&lt;mysqldump xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
&lt;database name="test"&gt;
  &lt;table_structure name="towns"&gt;
    &lt;field Field="id" Type="int(11)" Null="NO" Key="PRI" Extra="auto_increment" Comment="" /&gt;
    &lt;field Field="pref_code" Type="varchar(2)" Null="NO" Key="MUL" Default="" Extra="" Comment="" /&gt;
    &lt;field Field="city_code" Type="varchar(5)" Null="NO" Key="MUL" Default="" Extra="" Comment="" /&gt;
    &lt;field Field="town_code" Type="varchar(12)" Null="NO" Key="MUL" Default="" Extra="" Comment="" /&gt;
    &lt;field Field="latitude" Type="double" Null="YES" Key="" Default="0" Extra="" Comment="" /&gt;
    &lt;field Field="longitude" Type="double" Null="YES" Key="" Default="0" Extra="" Comment="" /&gt;
    &lt;field Field="upd_datetime" Type="datetime" Null="YES" Key="" Default="0000-00-00 00:00:00" Extra="" Comment="" /&gt;
    &lt;key Table="towns" Non_unique="0" Key_name="PRIMARY" Seq_in_index="1" Column_name="id" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_1" Seq_in_index="1" Column_name="pref_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_1" Seq_in_index="2" Column_name="city_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_1" Seq_in_index="3" Column_name="town_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_2" Seq_in_index="1" Column_name="city_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_2" Seq_in_index="2" Column_name="town_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;key Table="towns" Non_unique="1" Key_name="idx_3" Seq_in_index="1" Column_name="town_code" Collation="A" Cardinality="0" Null="" Index_type="BTREE" Comment="" Index_comment="" /&gt;
    &lt;options Name="towns" Engine="InnoDB" Version="10" Row_format="Compact" Rows="0" Avg_row_length="0" Data_length="16384" Max_data_length="0" Index_length="49152" Data_free="0" Auto_increment="1" Create_time="2015-08-18 14:06:07" Collation="utf8_general_ci" Create_options="" Comment="" /&gt;
  &lt;/table_structure&gt;
&lt;/database&gt;
&lt;/mysqldump&gt;
</code></pre>

<p>ちなみに、今回使用しているテーブルの CREATE 文は以下のようになっている。</p>

<pre><code class="sql">CREATE TABLE `towns` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pref_code` varchar(2) NOT NULL DEFAULT '',
  `city_code` varchar(5) NOT NULL DEFAULT '',
  `town_code` varchar(12) NOT NULL DEFAULT '',
  `latitude` double DEFAULT '0',
  `longitude` double DEFAULT '0',
  `upd_datetime` datetime DEFAULT '0000-00-00 00:00:00',
  PRIMARY KEY (`id`),
  KEY `idx_1` (`pref_code`,`city_code`,`town_code`),
  KEY `idx_2` (`city_code`,`town_code`),
  KEY `idx_3` (`town_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>

<h3>2. XSL テンプレートの作成</h3>

<p>以下のように XSL テンプレートを作成する。（あくまで一例。必要であれば適宜編集）</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0"&gt;

  &lt;xsl:output method="html" encoding="utf-8" version="1.0" /&gt;

  &lt;xsl:template match="mysqldump"&gt;
    &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;データベース・テーブル定義&lt;/title&gt;
      &lt;style type="text/css"&gt;
        h2 {
          background-color: #8fbc8f;
          padding:          5px;
        }
        h4 {
          color:            #666;
          margin-top:       5px;
          margin-bottom:    5px;
        }
        table {
          border-collapse:  separate;
          border-spacing:   0px;
          border-top:       1px solid #ccc;
          border-left:      1px solid #ccc;
          margin-bottom:    5px;
        }
        table th {
          text-align:       left;
          vertical-align:   top;
          color:            #444;
          background-color: #ccc;
          border-top:       1px solid #fff;
          border-left:      1px solid #fff;
          border-right:     1px solid #ccc;
          border-bottom:    1px solid #ccc;
          padding:          4px;
          white-space:      nowrap;
        }
        table td {
          background-color: #fafafa;
          border-right:     1px solid #ccc;
          border-bottom:    1px solid #ccc;
          padding:          4px;
          white-space:      nowrap;
        }
        .tbl-db-name {
          margin-bottom:    10px;
        }
        .th-db-title {
          background-color: #bdb76b;
          width:            200px;
        }
        .th-tbl-title {
          width:            200px;
        }
        .td-name {
          width:            200px;
        }
        .th-no {
          width:            50px;
          text-align:       right;
        }
        .th-field,
        .th-type,
        .th-extra,
        .th-default,
        .th-comment,
        .th-keyname {
          width:            200px;
        }
        .th-null,
        .th-key {
          width:            50px;
        }
        .th-columns {
          width:            400px;
        }
        .th-nonunique {
          width:            100px;
        }
        .td-no {
          text-align:       right;
        }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h2&gt;データベース・テーブル定義書&lt;/h2&gt;
      &lt;xsl:apply-templates select="database" /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="database"&gt;
    &lt;table class="tbl-db-name"&gt;
      &lt;tr&gt;
        &lt;th class="th-db-title"&gt;データベース名&lt;/th&gt;
        &lt;td class="td-name"&gt;&lt;xsl:value-of select="@name" /&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
    &lt;xsl:apply-templates select="table_structure" /&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="table_structure"&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th class="th-tbl-title"&gt;テーブル名&lt;/th&gt;
        &lt;td class="td-name"&gt;&lt;xsl:value-of select="@name" /&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;

    &lt;h4&gt;カラム情報&lt;/h4&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th class="th-no"     &gt;#&lt;/th&gt;
          &lt;th class="th-field"  &gt;フィールド名&lt;/th&gt;
          &lt;th class="th-type"   &gt;データ型&lt;/th&gt;
          &lt;th class="th-null"   &gt;Null&lt;/th&gt;
          &lt;th class="th-key"    &gt;キー&lt;/th&gt;
          &lt;th class="th-extra"  &gt;Extra&lt;/th&gt;
          &lt;th class="th-default"&gt;デフォルト&lt;/th&gt;
          &lt;th class="th-comment"&gt;備考&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;xsl:for-each select="field"&gt;
        &lt;tr&gt;
          &lt;td class="td-no"&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Field"   /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Type"    /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Null"    /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Key"     /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Extra"   /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Default" /&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="@Comment" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;h4&gt;インデックス情報&lt;/h4&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th class="th-keyname"  &gt;インデックス名&lt;/th&gt;
          &lt;th class="th-columns"  &gt;カラムリスト&lt;/th&gt;
          &lt;th class="th-nonunique"&gt;ユニーク&lt;/th&gt;
          &lt;th class="th-comment"  &gt;備考&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;xsl:for-each select="key"&gt;
          &lt;xsl:variable name="key_name" select="@Key_name" /&gt;
          &lt;xsl:if test="not(preceding-sibling::key[@Key_name=$key_name])"&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;xsl:value-of select="$key_name" /&gt;&lt;/td&gt;
            &lt;td&gt;
              &lt;xsl:for-each select="../key[@Key_name=$key_name]"&gt;
                &lt;xsl:value-of select="@Column_name"/&gt;
                &lt;xsl:if test="position()!=last()"&gt;
                  &lt;xsl:text&gt;, &lt;/xsl:text&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;
            &lt;/td&gt;
            &lt;td&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="@Non_unique='0'"&gt;1&lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;0&lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
            &lt;/td&gt;
            &lt;td&gt;&lt;xsl:value-of select="@Comment"    /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;/xsl:if&gt;
        &lt;/xsl:for-each&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="no_increment"&gt;
    &lt;xsl:param name="no" /&gt;

    &lt;xsl:value-of select="$no + 1" /&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/ecce393eb6056d4c92a7" title="Gist - XSL template to generate a HTML from a XML of MariaDB(MySQL)'s table definition.">Gist - XSL template to generate a HTML from a XML of MariaDB(MySQL)&rsquo;s table definition.</a></li>
</ul>


<h3>3. HTML の生成</h3>

<p><code>xsltproc</code> コマンドを使用して HTML を生成する。</p>

<pre><code class="text">$ xsltproc --output test_towns.html table_definition.xsl test_towns.xml
</code></pre>

<h3>4. HTML の確認</h3>

<p>生成された HTML を確認してみる。</p>

<p>``` html test_towns.html
&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD HTML 4.0 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/REC-html40/loose.dtd">http://www.w3.org/TR/REC-html40/loose.dtd</a>&rdquo;>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>データベース・テーブル定義</title></p>



<p></head>
<body></p>

<h2>データベース・テーブル定義書</h2>


<table class="tbl-db-name"><tr>
<th class="th-db-title">データベース名</th>
<td class="td-name">test</td>
</tr></table>


<table><tr>
<th class="th-tbl-title">テーブル名</th>
<td class="td-name">towns</td>
</tr></table>


<h4>カラム情報</h4>


<table>
<thead><tr>
<th class="th-no">#</th>
<th class="th-field">フィールド名</th>
<th class="th-type">データ型</th>
<th class="th-null">Null</th>
<th class="th-key">キー</th>
<th class="th-extra">Extra</th>
<th class="th-default">デフォルト</th>
<th class="th-comment">備考</th>
</tr></thead>
<tbody>
<tr>
<td class="td-no">1</td>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td></td>
<td></td>
</tr>
<tr>
<td class="td-no">2</td>
<td>pref_code</td>
<td>varchar(2)</td>
<td>NO</td>
<td>MUL</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td class="td-no">3</td>
<td>city_code</td>
<td>varchar(5)</td>
<td>NO</td>
<td>MUL</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td class="td-no">4</td>
<td>town_code</td>
<td>varchar(12)</td>
<td>NO</td>
<td>MUL</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td class="td-no">5</td>
<td>latitude</td>
<td>double</td>
<td>YES</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td class="td-no">6</td>
<td>longitude</td>
<td>double</td>
<td>YES</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td class="td-no">7</td>
<td>upd_datetime</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>0000-00-00 00:00:00</td>
<td></td>
</tr>
</tbody>
</table>


<h4>インデックス情報</h4>


<table>
<thead><tr>
<th class="th-keyname">インデックス名</th>
<th class="th-columns">カラムリスト</th>
<th class="th-nonunique">ユニーク</th>
<th class="th-comment">備考</th>
</tr></thead>
<tbody>
<tr>
<td>PRIMARY</td>
<td>id</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>idx_1</td>
<td>pref_code, city_code, town_code</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>idx_2</td>
<td>city_code, town_code</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>idx_3</td>
<td>town_code</td>
<td>0</td>
<td></td>
</tr>
</tbody>
</table>


<p></body>
</html>
```</p>

<p>さらに、 HTML ファイルをブラウザで開いて確認してみる。</p>

<p><img src="/images/2015/09/12/TABLE_DEF_HTML.png" title="TABLE_DEF_HTML" alt="TABLE_DEF_HTML" /></p>

<hr />

<p>大量にテーブル定義書を生成したければシェル化するのもよいでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
