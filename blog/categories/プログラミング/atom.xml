<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: プログラミング | mk-mode BLOG]]></title>
  <link href="http://komasaru.github.io/blog/categories/プログラミング/atom.xml" rel="self"/>
  <link href="http://komasaru.github.io/"/>
  <updated>2015-11-15T12:44:14+09:00</updated>
  <id>http://komasaru.github.io/</id>
  <author>
    <name><![CDATA[mk-mode.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Nokogiri による XML 解析の速度検証！]]></title>
    <link href="http://komasaru.github.io/blog/2015/09/22/ruby-verify-xml-parsing-by-nokogiri/"/>
    <updated>2015-09-22T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/09/22/ruby-verify-xml-parsing-by-nokogiri</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Ruby で HTML/XML パーサの Nokogiri を使用して XML を解析する際、名前空間(Namespace)が宣言されている場合は厳密に指定する必要があるものだと考えております。</p>

<p>しかし、実際は名前空間を指定せずに解析することも可能です。<br/>
（実際、 XML 内の名前空間を削除するメソッドも用意されています。しかし、そのメソッドは名前空間について理解していない人のためのものであり、一般的には使用すべきではありません）</p>

<p>今回は、各種方法で解析し、どの方法が高速であるかを検証してみました。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Ruby 2.2.3-p173 での作業を想定。</li>
<li>以下で紹介する検証結果は、使用する XML の構造等により若干異なることもあるかもしれない、ということに留意。</li>
</ul>


<h3>1. 検証に使用する XML ファイル</h3>

<p>以下のような XML を使用する。（実際の「気象庁防災情報 XML」通知用 Atom フィードを流用。情報の内容は24時間以内に <code>link</code> タグ内の URL にアクセスして得ることになっている）</p>

<pre><code class="xml test_nokogiri.xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja"&gt;
&lt;title&gt;JMAXML publishing feed&lt;/title&gt;
&lt;subtitle&gt;this feed is published by JMA&lt;/subtitle&gt;
&lt;updated&gt;2015-08-27T17:28:02+09:00&lt;/updated&gt;
&lt;id&gt;urn:uuid:d38e0e80-12ba-3236-b10f-256b78a08995&lt;/id&gt;
&lt;link href="http://www.jma.go.jp/" rel="related"/&gt;
&lt;link href="http://xml.kishou.go.jp/feed/other.xml" rel="self"/&gt;
&lt;rights&gt;Published by Japan Meteorological Agency&lt;/rights&gt;

&lt;entry&gt;
&lt;title&gt;地方海上警報&lt;/title&gt;
&lt;id&gt;urn:uuid:ac97395c-e388-33a9-922f-ab2a32e61bb1&lt;/id&gt;
&lt;updated&gt;2015-08-27T08:27:18Z&lt;/updated&gt;
&lt;author&gt;&lt;name&gt;新潟地方気象台&lt;/name&gt;&lt;/author&gt;
&lt;link href="http://xml.kishou.go.jp/data/ac97395c-e388-33a9-922f-ab2a32e61bb1.xml" type="application/xml"/&gt;
&lt;content type="text"&gt;【新潟海上気象】&lt;/content&gt;
&lt;/entry&gt;
&lt;entry&gt;
&lt;title&gt;地方海上警報&lt;/title&gt;
&lt;id&gt;urn:uuid:b42a06f2-a6f0-351a-a8c4-3619a847f66d&lt;/id&gt;
&lt;updated&gt;2015-08-27T08:27:02Z&lt;/updated&gt;
&lt;author&gt;&lt;name&gt;仙台管区気象台&lt;/name&gt;&lt;/author&gt;
&lt;link href="http://xml.kishou.go.jp/data/b42a06f2-a6f0-351a-a8c4-3619a847f66d.xml" type="application/xml"/&gt;
&lt;content type="text"&gt;【仙台海上気象】&lt;/content&gt;
&lt;/entry&gt;
&lt;entry&gt;
&lt;title&gt;紫外線観測データ&lt;/title&gt;
&lt;id&gt;urn:uuid:f27e93c8-ff97-376d-b3b0-5307d07e4a24&lt;/id&gt;
&lt;updated&gt;2015-08-27T08:27:10Z&lt;/updated&gt;
&lt;author&gt;&lt;name&gt;気象庁地球環境・海洋部&lt;/name&gt;&lt;/author&gt;
&lt;link href="http://xml.kishou.go.jp/data/f27e93c8-ff97-376d-b3b0-5307d07e4a24.xml" type="application/xml"/&gt;
&lt;content type="text"&gt;【紫外線観測データ】&lt;/content&gt;
&lt;/entry&gt;
&lt;/feed&gt;
</code></pre>

<h3>2. 検証用 Ruby スクリプトの作成</h3>

<ul>
<li>以下のスクリプト内で指定する名前空間は、 &ldquo;text_nokogiri.xml&rdquo; 内で宣言されているものと同じ。</li>
<li><code>entry</code> ノードをループし、各 <code>title</code> ノードのテキストを取得するだけの簡単な処理を 10,000 回繰り返す。</li>
<li>今回は７種類（スクリプト内コメント参照）の解析方法で検証する。</li>
<li>以下のスクリプト内の XPath での「Namespace 指定なし」とは、 Nokogiri での厳密な指定をしないという意味。</li>
</ul>


<pre><code class="ruby test_nokogiri_xml.rb">#! /usr/local/bin/ruby
# coding: utf-8
#
# Ruby script to verify the speed of xml parsing by Nokogiri.
#
#++
require 'benchmark'
require 'nokogiri'

class TestNokogiriXml
  def initialize
    @xml  = Nokogiri::XML(File.read("test_nokogiri.xml"))
    @secs = 10000
    @ns   = {"a" =&gt; "http://www.w3.org/2005/Atom"}
  end

  def exec
    # 1. css メソッド(CSS セレクタ)による解析
    printf("CASE-1: %.4f secs.\n", case_1)

    # 2. search メソッド(CSS セレクタ)による解析
    printf("CASE-2: %.4f secs.\n", case_2)

    # 3. search メソッド(XPath, Namespace 指定なし)による解析
    printf("CASE-3: %.4f secs.\n", case_3)

    # 4. / メソッド(CSS セレクタ)による解析
    printf("CASE-4: %.4f secs.\n", case_4)

    # 5. / メソッド(XPath, Namespace 指定なし)による解析
    printf("CASE-5: %.4f secs.\n", case_5)

    # 6. xpath メソッド(XPath, Namespace 指定なし)による解析
    printf("CASE-6: %.4f secs.\n", case_6)

    # 7. xpath メソッド(XPath, Namespace 指定あり)による解析
    printf("CASE-7: %.4f secs.\n", case_7)
  rescue =&gt; e
    $stderr.puts "[#{self.class.name}.#{__method__}] #{e}"
    e.backtrace.each{ |tr| $stderr.puts "\t#{tr}" }
    exit 1
  end

  private

  def case_1
    return Benchmark.realtime do
      @secs.times do |i|
        @xml.css("entry").each do |e|
          title = e.css("title").first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_2
    return Benchmark.realtime do
      @secs.times do |i|
        @xml.search("entry").each do |e|
          title = e.search("title").first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_3
    return Benchmark.realtime do
      @secs.times do |i|
        @xml.search("//xmlns:entry").each do |e|
          title = e.search("./xmlns:title").first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_4
    return Benchmark.realtime do
      @secs.times do |i|
        (@xml/"entry").each do |e|
          title = (e/"title").first.text
        end
        # 以下でも同様。しかし、ごく少し遅い。
        #(@xml/:entry).each do |e|
        #  title = (e/:title).first.text
        #end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_5
    return Benchmark.realtime do
      @secs.times do |i|
        (@xml/"//xmlns:entry").each do |e|
          title = (e/"./xmlns:title").first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_6
    return Benchmark.realtime do
      @secs.times do |i|
        @xml.xpath("//xmlns:entry").each do |e|
          title = e.xpath("xmlns:title").first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end

  def case_7
    return Benchmark.realtime do
      @secs.times do |i|
        @xml.xpath("//a:entry", @ns).each do |e|
          title = e.xpath("a:title", @ns).first.text
        end
      end
    end
  rescue =&gt; e
    raise
  end
end

TestNokogiriXml.new.exec
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/1f737b67baba38213570" title="Gist - Ruby script to verify the speed of xml parsing by Nokogiri. ">Gist - Ruby script to verify the speed of xml parsing by Nokogiri. </a></li>
</ul>


<h3>3. Ruby スクリプトの実行</h3>

<pre><code class="text">$ ./test.rb
CASE-1: 2.3432 secs.
CASE-2: 2.4821 secs.
CASE-3: 2.0588 secs.
CASE-4: 2.4949 secs.
CASE-5: 2.0672 secs.
CASE-6: 1.7549 secs.
CASE-7: 1.5359 secs.
</code></pre>

<h3>4. 検証結果について</h3>

<ul>
<li>何回か実行してみたが、全て同じような結果となった。</li>
<li><code>xpath</code> メソッドは <code>css</code>, <code>search</code>, <code>/</code> メソッドより高速に解析することができる。</li>
<li><code>xpath</code> メソッドで厳密に名前空間を指定した方が、指定せずに解析するより高速である。</li>
<li>要は、XML を解析する際は <code>xpath</code> メソッドで名前空間を指定しましょう、ということ。</li>
<li>今回の検証結果が全てという訳ではない（場合によっては「一概には言えない」ということがあるかもしれない）</li>
</ul>


<hr />

<p>当方、以前は CSS セレクタを使用して XML 解析を行なっていた時期もありましたが、現在は XPath で厳密に名前空間を指定して解析を行うようにしています。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - dRuby でジョブキューサーバ構築！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/29/ruby-job-queue-server-construction-by-druby/"/>
    <updated>2015-08-29T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/29/ruby-job-queue-server-construction-by-druby</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>前回に引き続き、Ruby の分散オブジェクトプログラミングするためのライブラリ dRuby についての内容です。</p>

<p>今回は、 dRuby を利用してジョブキューサーバ＆クライアントを構築してみました。</p>

<p>要は、キューに順次プッシュした内容をクライアント側から順次ポップする仕組みのことです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Ruby 2.2.3-p173 での作業を想定。</li>
<li>本来は複数のマシンで実行することが多いと思うが、今回は１つのマシンでテストする。</li>
<li>dRuby の簡単な使用例は「<a href="/2015/08/25/ruby-distributed-processing-by-druby" title="Ruby - dRuby で分散処理！">Ruby - dRuby で分散処理！</a>」を参照。</li>
</ul>


<h3>1. サーバ側スクリプトの作成例</h3>

<p>Queue オブジェクトを生成して待ち受けるのみの簡単なスクリプト。</p>

<pre><code class="ruby queue_server.rb">#!/usr/local/bin/ruby
# codeing: utf-8
require 'drb/drb'

q = Queue.new
DRb.start_service("druby://localhost:8787", q, safe_level: 1)
DRb.thread.join
</code></pre>

<ul>
<li><code>start_service</code> の <code>safe_level</code> を <code>1</code> に設定しているのは、 <code>instance_eval</code> による危険性を防ぐための処置。</li>
</ul>


<h3>2. クライアント側 Pop スクリプトの作成例</h3>

<p>キューサーバから順次ポップして5秒後にコンソール出力するのみの簡単なスクリプト。（キューに溜め込まれるデータは時刻文字列を想定している）</p>

<pre><code class="ruby pop_client.rb">#!/usr/local/bin/ruby
# coding: utf-8
require 'drb/drb'

obj = DRbObject.new_with_uri("druby://localhost:8787")
loop do |a|
  tm = obj.pop
  sleep 5
  puts "Received at #{tm}."
end
</code></pre>

<h3>3. クライアント側 Push スクリプトの作成例</h3>

<p>キューサーバへ現在時刻の文字列をプッシュするのみの簡単なスクリプト。</p>

<pre><code class="ruby push_client.rb">#! /usr/local/bin/ruby
# coding: utf-8
require 'drb/drb'

obj = DRbObject.new_with_uri("druby://localhost:8787")
tm = Time.now.strftime("%Y-%m-%d %H:%M:%S")
obj.push tm
puts "Sended at #{tm}."
</code></pre>

<h3>4. 動作確認</h3>

<p>まず、１つ目の端末を立ち上げて、サーバ側スクリプトを実行する。</p>

<pre><code class="text">$ ./queue_server.rb
</code></pre>

<p>次に、２つ目の端末を立ち上げて、クライアント側 Pop スクリプトを実行する。</p>

<pre><code class="text">$ ./pop_client.rb
</code></pre>

<p>最後に、３つ目の端末を立ち上げて、クライアント側 Push スクリプトを何度も連続して実行してみる。</p>

<pre><code class="text">$ ./push_client.rb
Sended at 2015-07-28 23:34:02.
$ ./push_client.rb
Sended at 2015-07-28 23:34:03.
$ ./push_client.rb
Sended at 2015-07-28 23:34:03.
$ ./push_client.rb
Sended at 2015-07-28 23:34:04.
$ ./push_client.rb
Sended at 2015-07-28 23:34:04.
</code></pre>

<p>すると、２つ目の Pop クライアントの端末に５秒間隔で出力がなされるはずである。</p>

<pre><code class="text">$ ./pop_client.rb
Received at 2015-07-28 23:34:02.
Received at 2015-07-28 23:34:03.
Received at 2015-07-28 23:34:03.
Received at 2015-07-28 23:34:04.
Received at 2015-07-28 23:34:04.
</code></pre>

<h3>5. 注意</h3>

<ul>
<li>dRuby で構築したサーバをインターネットで外部に公開すべきではない。</li>
<li>ローカルで使用する際もセキュリティ面に注意する。</li>
</ul>


<h3>6. 参考サイト</h3>

<ul>
<li><a href="http://docs.ruby-lang.org/ja/2.2.0/library/drb.html" title="library drb(Ruby2.2.0)">library drb(Ruby2.2.0)</a></li>
</ul>


<hr />

<p>当方、一度に並列で処理をされては困るような場合に、この仕組みを応用して順次処理を行うようにしています。<br/>
（インターネット上からデータが配信されたら処理を行うようなシステムの場合に、データが集中的に配信されてもマシンに負荷をかけないようにするため）</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - dRuby で分散処理！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/25/ruby-distributed-processing-by-druby/"/>
    <updated>2015-08-25T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/25/ruby-distributed-processing-by-druby</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>dRuby とは、 Ruby で分散オブジェクトプログラミングするためのライブラリです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Ruby 2.2.3-p173 での作業を想定。</li>
<li>本来は複数のマシンで実行することが多いと思うが、今回は１つのマシンでテストする。</li>
<li>特に別途インストールの必要なライブラリ等はない。</li>
</ul>


<h3>1. サーバ側スクリプトの作成例</h3>

<p>日付・時刻の文字列を返すだけの簡単な例。</p>

<pre><code class="ruby druby_server.rb">#!/usr/local/bin/ruby
# coding: utf-8
require 'drb/drb'

# 通信を待ち受ける URI
URI="druby://localhost:8787"

class DrubyServer
  def get_cur_time
    cur_time = Time.now.strftime("%Y年%m月%d日 %H時%M分%S秒")
    msg = "ただいま #{cur_time} です。"
    puts msg
    return msg
  end
end

# リクエストを受け付けるオブジェクト
obj = DrubyServer.new
# サーバの起動
DRb.start_service(URI, obj, safe_level: 1)
# DRb スレッド終了の待ち受け
DRb.thread.join
</code></pre>

<ul>
<li><code>start_service</code> の <code>safe_level</code> を <code>1</code> に設定しているのは、 <code>instance_eval</code> による危険性を防ぐための処置。</li>
</ul>


<h3>2. クライアント側スクリプトの作成例</h3>

<p>サーバのメソットを呼び出す簡単な例。</p>

<pre><code class="ruby druby_client.rb">#!/usr/local/bin/ruby
# coding: utf-8
require 'drb/drb'

# 接続先 URI
URI="druby://localhost:8787"

# リモートオブジェクトの取得
obj = DRbObject.new_with_uri(URI)
# リモートメソッドの呼び出し
puts obj.get_cur_time
</code></pre>

<h3>3. 動作確認</h3>

<p>まず、１つ目の端末を立ち上げて、サーバ側スクリプトを実行する。</p>

<pre><code class="text">$ ./druby_server.rb
</code></pre>

<p>そして、もう１つ端末を立ち上げて、クライアント側スクリプトを実行する。</p>

<pre><code class="text">$ ./druby_client.rb
ただいま 2015年07月22日 24時31分16秒 です。
$ ./druby_client.rb
ただいま 2015年07月22日 24時32分30秒 です。
</code></pre>

<p>クライアント側スクリプトを実行する度にサーバ側で処理した結果が出力されるはずである。<br/>
また、この時サーバ側の端末にも同じ出力がされるはずである。</p>

<pre><code class="text">$ ./druby_server.rb
ただいま 2015年07月22日 24時31分16秒 です。
ただいま 2015年07月22日 24時32分30秒 です。
</code></pre>

<h3>4. 注意</h3>

<ul>
<li>dRuby で構築したサーバをインターネットで外部に公開すべきではない。</li>
<li>ローカルで使用する際もセキュリティ面に注意する。</li>
</ul>


<h3>5. 参考サイト</h3>

<ul>
<li><a href="http://docs.ruby-lang.org/ja/2.2.0/library/drb.html" title="library drb (Ruby 2.2.0)">library drb (Ruby 2.2.0)</a></li>
</ul>


<hr />

<p>この dRuby による分散処理をいろいろ応用できそうです。</p>

<p>実際、目論んでいることもありますし。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Rroonga で全文検索！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/17/ruby-rroonga-fulltext-searching/"/>
    <updated>2015-08-17T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/17/ruby-rroonga-fulltext-searching</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Ruby でカラムストア機能付き全文検索エンジン Groonga の機能を容易に使用できる Rroonga を使用してみました。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.2(64bit) での作業を想定。</li>
<li>Ruby 2.2.2-p95 での作業を想定。</li>
<li>カラムストア機能付き全文検索エンジン Groonga がインストール済みであること。</li>
</ul>


<h3>1. Rroonga のインストール</h3>

<p>以下のようにしてインストールする。<br/>
（ちなみ、 Groonga 未インストールなら、ここでインストールされるはず。（当方 Groonga インストール済みなので、未確認））</p>

<pre><code class="text">$ sudo gem install rroonga
</code></pre>

<h3>2. データベースの作成</h3>

<p>簡単な都道府県名データベースを作成してみる。</p>

<p>取り急ぎ対話形式で作業を行いたいので、 pry(or irb) に入る。（プロンプトを簡易表示。 <code>groonga</code> を <code>require</code> して）</p>

<pre><code class="text">$ pry --simple-prompt -r groonga
</code></pre>

<p>まず、エンコーディングの設定を行う。（今回は Linux なので UTF-8 に設定）</p>

<pre><code class="text">&gt;&gt; Groonga::Context.default_options = {:encoding =&gt; :utf8}
=&gt; {:encoding=&gt;:utf8}
</code></pre>

<p>そして、データベースを作成する。（データベースファイル名を指定）</p>

<pre><code class="text">&gt;&gt; Groonga::Database.create(:path =&gt; "/path/to/prefs.db")
=&gt; #&lt;Groonga::Database id: &lt;nil&gt;, name: (anonymous), path: &lt;/path/to/prefs.db&gt;, domain: (nil), range: (nil), flags: &lt;&gt;&gt;
</code></pre>

<h3>3. テーブルの作成</h3>

<p>都道府県名テーブルを作成してみる。（テーブル名、テーブルタイプを指定）<br/>
（テーブルタイプには <code>hash</code>, <code>patricia_trie</code>, <code>double_array_trie</code>, <code>array</code> が指定可能）</p>

<pre><code class="text">&gt;&gt; Groonga::Schema.create_table("Prefs", :type =&gt; :hash) do |tbl|
 |   tbl.text("pref_name")
 | end
=&gt; [#&lt;Groonga::Schema::TableDefinition:0x007f9fe62cef60
  @definitions=
   [#&lt;Groonga::Schema::ColumnDefinition:0x007f9fe62ce1f0
     @name="pref_name",
     @options={:persistent=&gt;true, :named_path=&gt;nil},
     @type="Text"&gt;],
  @name="Prefs",
  @options=
   {:context=&gt;
     #&lt;Groonga::Context encoding: &lt;:utf8&gt;, database: &lt;#&lt;Groonga::Database id: &lt;nil&gt;, name: (anonymous), path: &lt;/path/to/prefs.db&gt;, domain: (nil), range: (nil), flags: &lt;&gt;&gt;&gt;&gt;,
    :type=&gt;:hash},
  @table_type=Groonga::Hash&gt;]
</code></pre>

<p>テーブルが作成されたか確認してみる。</p>

<pre><code class="text">&gt;&gt; prefs = Groonga["Prefs"]
=&gt; #&lt;Groonga::Hash id: &lt;256&gt;, name: &lt;Prefs&gt;, path: &lt;/path/to/prefs.db.0000100&gt;, domain: &lt;ShortText&gt;, range: (nil), flags: &lt;&gt;, size: &lt;0&gt;, encoding: &lt;:utf8&gt;, default_tokenizer: (nil), token_filters: [], normalizer: (nil)&gt;
&gt;&gt; prefs.size
=&gt; 0
</code></pre>

<h3>4. レコードの追加</h3>

<p>以下のようにして、テーブルにレコードを追加していく。（47都道府県分。別途作成しておいた配列をループさせて登録するのがよいだろう）</p>

<pre><code class="text">&gt;&gt; prefs.add("Hokkaido", :pref_name =&gt; "北海道")
=&gt; #&lt;Groonga::Record:0x007f9fe69e4480 ..., attributes: {"_id"=&gt;1, "_key"=&gt;"Hokkaido", "pref_name"=&gt;"北海道"}&gt;
</code></pre>

<p>以下のような方法で追加することも可能。</p>

<pre><code class="text">&gt;&gt; prefs.add("Aomoriken")
=&gt; #&lt;Groonga::Record:0x007f9fe6755020 ..., attributes: {"_id"=&gt;3, "_key"=&gt;"Aomoriken", "pref_name"=&gt;nil}&gt;
&gt;&gt; prefs["Aomoriken"].pref_name = "青森県"
=&gt; "青森県"
</code></pre>

<p>ちなみに、削除するには以下のようにする。</p>

<pre><code class="text">&gt;&gt; prefs.delete("Aomoriken")
=&gt; nil
</code></pre>

<h3>5. レコードの参照</h3>

<p>登録したレコードを参照してみる。</p>

<pre><code class="text">&gt;&gt; prefs["Shimaneken"]
=&gt; #&lt;Groonga::Record:0x007f9fe671a1f0 ..., attributes: {"_id"=&gt;32, "_key"=&gt;"Shimaneken", "pref_name"=&gt;"島根県"}&gt;

&gt;&gt; prefs["Shimaneken"].id
=&gt; 32

&gt;&gt; prefs["Shimaneken"].key
=&gt; "Shimaneken"

&gt;&gt; prefs["Shimaneken"].pref_name
=&gt; "島根県"

&gt;&gt; prefs.size
=&gt; 47
</code></pre>

<h3>6. 全文検索用語彙テーブルの作成</h3>

<p>全文検索用語彙テーブルを作成する。（以下は、テーブルタイプを PatriciaTrie に、ノーマライザを大文字小文字の区別をしない NormalizerAuto に、デフォルトトークナイザを N-gram の一種バイグラムに設定する例）</p>

<pre><code class="text">&gt;&gt; Groonga::Schema.create_table("Terms",
 |   :type =&gt; :patricia_trie,
 |   :normalizer =&gt; :NormalizerAuto,
 | :default_tokenizer =&gt; "TokenBigram")
=&gt; [#&lt;Groonga::Schema::TableDefinition:0x007f9fe6bb9cb0
  @definitions=[],
  @name="Terms",
  @options=
   {:context=&gt;
     #&lt;Groonga::Context encoding: &lt;:utf8&gt;, database: &lt;#&lt;Groonga::Database id: &lt;nil&gt;, name: (anonymous), path: &lt;/path/to/prefs.db&gt;, domain: (nil), range: (nil), flags: &lt;&gt;&gt;&gt;&gt;,
    :type=&gt;:patricia_trie,
    :normalizer=&gt;:NormalizerAuto,
    :default_tokenizer=&gt;"TokenBigram"},
  @table_type=Groonga::PatriciaTrie&gt;]
</code></pre>

<h3>7. 全文検索用語彙テーブルのインデックス定義</h3>

<p>今回は都道府県名ローマ字で検索してみることにする。</p>

<pre><code class="text">&gt;&gt; Groonga::Schema.change_table("Terms") do |tbl|
 |   tbl.index("Prefs.pref_name")
 | end
=&gt; [#&lt;Groonga::Schema::TableDefinition:0x007f9fe6a823d8
  @definitions=
   [#&lt;Groonga::Schema::IndexColumnDefinition:0x007f9fe6a81d48
     @name=nil,
     @options={:persistent=&gt;true, :named_path=&gt;nil},
     @target_columns=["pref_name"],
     @target_table="Prefs"&gt;],
  @name="Terms",
  @options=
   {:context=&gt;
     #&lt;Groonga::Context encoding: &lt;:utf8&gt;, database: &lt;#&lt;Groonga::Database id: &lt;nil&gt;, name: (anonymous), path: &lt;/path/to/prefs.db&gt;, domain: (nil), range: (nil), flags: &lt;&gt;&gt;&gt;&gt;,
    :change=&gt;true},
  @table_type=Groonga::Array&gt;]
</code></pre>

<h3>8. 検索の確認</h3>

<pre><code class="text">&gt;&gt; prefs_shimane = prefs.select { |rec| rec.pref_name =~ "島根県" }    =&gt; #&lt;Groonga::Hash id: &lt;2147483655&gt;, name: (anonymous), path: (temporary), domain: &lt;Prefs&gt;, range: (nil), flags: &lt;WITH_SUBREC&gt;, size: &lt;1&gt;, encoding: &lt;:utf8&gt;, default_tokenizer: (nil), token_filters: [], normalizer: (nil)&gt;

&gt;&gt; prefs_shimane.size
=&gt; 1

&gt;&gt; prefs_shimane.collect { |rec| rec.key.key }
=&gt; ["Shimaneken"]

&gt;&gt; prefs_shimane.collect { |rec| rec["_key"] }
=&gt; ["Shimaneken"]
</code></pre>

<h3>9. 参考サイト</h3>

<ul>
<li><a href="http://groonga.org/ja/" title="Groonga - カラムストア機能付き全文検索エンジン">Groonga - カラムストア機能付き全文検索エンジン</a></li>
<li><a href="http://ranguba.org/ja/" title="RubyでGroonga使って全文検索 - ラングバ">RubyでGroonga使って全文検索 - ラングバ</a></li>
</ul>


<hr />

<p>その他の詳細な使用方法は実際に Ruby コーディングしながら覚えることになるでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - gnuplot でグラフ描画！]]></title>
    <link href="http://komasaru.github.io/blog/2015/08/13/ruby-graph-drawing-by-gnuplot/"/>
    <updated>2015-08-13T00:20:00+09:00</updated>
    <id>http://komasaru.github.io/blog/2015/08/13/ruby-graph-drawing-by-gnuplot</id>
    <content type="html"><![CDATA[<p>こんばんは。</p>

<p>Ruby で容易にグラフを描画できる RubyGems ライブラリ gnuplot を使用してみました。</p>

<p>RubyGems ライブラリ gnuplot は、2次元や3次元のグラフを描画するためのコマンドラインツール Gnuplot を Ruby で使用できるようにラップしたものです。</p>

<!--more-->


<h3>0. 前提条件</h3>

<ul>
<li>Linux Mint 17.1(64bit) 一般ユーザでの作業を想定。</li>
<li>Ruby 2.2.2-p95 での作業を想定。</li>
<li>Gnuplot インストール済みであること。（<a href="/2015/07/30/linux-mint-installation-gnuplot/" title="Linux Mint - Gnuplot でグラフ描画！">Linux Mint - Gnuplot でグラフ描画！</a>）</li>
</ul>


<h3>1. RubyGems パッケージのインストール</h3>

<pre><code class="text">$ sudo gem install gnuplot
</code></pre>

<h3>2. 動作確認</h3>

<h4>2-1. 作成例・１</h4>

<p>単純な<script type="math/tex">sin</script>曲線・<script type="math/tex">cos</script>曲線を描画する例。</p>

<pre><code class="ruby gnuplot_1.rb">#! /usr/local/bin/ruby
#-----------------------------------------------
# Ruby script to draw a graph by gnuplot.(Ex.1)
#-----------------------------------------------
require 'gnuplot'

Gnuplot.open do |gp|
  Gnuplot::Plot.new(gp) do |plot|
    plot.xrange "[-10:10]"
    plot.title  "作成例１"
    plot.xlabel "x"
    plot.ylabel "y"
    plot.grid

    plot.data &lt;&lt; Gnuplot::DataSet.new("sin(x)") do |ds|
      ds.with      = "lines"
      ds.linewidth = 2
    end

    plot.data &lt;&lt; Gnuplot::DataSet.new("cos(x)") do |ds|
      ds.with      = "lines"
      ds.linewidth = 2
    end
  end
end
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/18575f0245952cae7d02" title="Gist - Ruby script to draw a graph by gnuplot.(Ex.1)">Gist - Ruby script to draw a graph by gnuplot.(Ex.1)</a></li>
</ul>


<p>そして、実行権限を付与して実行。</p>

<pre><code class="text">$ sudo chmod +x gnuplot_1.rb

$ ./gnuplot_1.rb
</code></pre>

<p>Gnuplot ウィンドウが開き、グラフが描画される。</p>

<p><img src="/images/2015/08/13/GNUPLOT_1.png" title="GNUPLOT_1" alt="GNUPLOT_1" /></p>

<p>但し、環境によってはこのウィンドウを閉じようとしてもうまく閉じれないかもしれない。（termnal が &ldquo;wxt&rdquo; の場合。 terminal が &ldquo;x11&rdquo; 等なら閉じれるが、日本語は使用できない）<br/>
ちなみに、本家の gnuplot では、この問題は &ldquo;Close&rdquo; を &ldquo;exit&rdquo; でなく &ldquo;exit gnuplot&rdquo; にバインドすれば解決するようだが、今回の RubyGems ライブラリでは通用しない模様。（試行してみた結果）</p>

<h4>2-2. 作成例・２</h4>

<p><script type="math/tex">y=x<sup>3</sup> - 2x + 2 \ (x={-2.0,-1.9,\cdots,1.9,2.0})</script>のグラフを PNG ファイルに描画・出力する例。</p>

<pre><code class="ruby gnuplot_2.rb">#! /usr/local/bin/ruby
#-----------------------------------------------
# Ruby script to draw a graph by gnuplot.(Ex.2)
#-----------------------------------------------
require 'gnuplot'

Gnuplot.open do |gp|
  Gnuplot::Plot.new(gp) do |plot|
    plot.terminal "png enhanced font 'IPA P ゴシック' fontscale 1.2"
    plot.output   "gnuplot_2.png"
    plot.title    "作成例２"
    plot.xlabel   "x"
    plot.ylabel   "y=x^3-2x+2"
    plot.grid

    x = (-20..20).collect { |v| v.to_f / 10.0 }
    y = x.collect { |v| v ** 3 - 2 * v + 2}

    plot.data &lt;&lt; Gnuplot::DataSet.new([x, y]) do |ds|
      ds.with      = "linespoints"  # 点のみなら "points"
      ds.linewidth = 2
      ds.linecolor = 3
      ds.notitle
    end
  end
end
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/27e65a70d4681dd73370" title="Gist - Ruby script to draw a graph by gnuplot.(Ex.2)">Gist - Ruby script to draw a graph by gnuplot.(Ex.2)</a></li>
</ul>


<p>そして、実行権限を付与して実行。</p>

<pre><code class="text">$ sudo chmod +x gnuplot_2.rb

$ ./gnuplot_2.rb
</code></pre>

<p>&ldquo;gnuplot_2.png&rdquo; というファイルが出力される。</p>

<p><img src="/images/2015/08/13/GNUPLOT_2.png" title="GNUPLOT_2" alt="GNUPLOT_2" /></p>

<h4>2-3. 作成例・３</h4>

<p><script type="math/tex">z=sin(x)cos(x)</script>の三次元グラフを PNG ファイルに描画・出力する例。</p>

<pre><code class="ruby gnuplot_3.rb">#! /usr/local/bin/ruby
#-----------------------------------------------
# Ruby script to draw a graph by gnuplot.(Ex.3)
#-----------------------------------------------

require 'gnuplot'

Gnuplot.open do |gp|
  Gnuplot::SPlot.new(gp) do |plot|
    plot.terminal "png enhanced font 'IPA P ゴシック' fontscale 1.2"
    plot.output   "gnuplot_3.png"
    plot.set      "object 1 rect from screen 0,0 to screen 1,1 fc rgb '#D0D0E0' fillstyle solid 1.0 behind"
    plot.title    "作成例３"
    plot.xrange   "[-10:10]"
    plot.yrange   "[-10:10]"
    plot.xlabel   "x"
    plot.ylabel   "y"
    plot.zlabel   "z"
    plot.pm3d
    plot.grid

    plot.data &lt;&lt; Gnuplot::DataSet.new("sin(x)*cos(y)") do |ds|
      ds.with      = "lines"
      ds.linecolor = 6
    end
  end
end
</code></pre>

<ul>
<li><a href="https://gist.github.com/komasaru/1395add506fd9a1a4bd6" title="Gist - Ruby script to draw a graph by gnuplot.(Ex.3)">Gist - Ruby script to draw a graph by gnuplot.(Ex.3)</a></li>
</ul>


<p>そして、実行権限を付与して実行。</p>

<pre><code class="text">$ sudo chmod +x gnuplot_3.rb

$ ./gnuplot_3.rb
</code></pre>

<p><img src="/images/2015/08/13/GNUPLOT_3.png" title="GNUPLOT_3" alt="GNUPLOT_3" /></p>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.gnuplot.info/" title="gnuplot">gnuplot</a></li>
<li><a href="https://rubygems.org/gems/gnuplot" title="gnuplot - RubyGems.org - your community gem host">gnuplot - RubyGems.org - your community gem host</a></li>
</ul>


<hr />

<p>Ruby で処理した得た数値をグラフ化することが多い場合は重宝するでしょう。</p>

<p>以上。</p>
]]></content>
  </entry>
  
</feed>
